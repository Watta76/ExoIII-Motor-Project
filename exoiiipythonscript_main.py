# -*- coding: utf-8 -*-
"""ExoIIIPythonScript_Main

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hCqFYCrVvYYEHDhyLpCL5VHv4PJLARPq

# **Initialization**
"""

# import the necessary libraries

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.collections import LineCollection
from matplotlib import colorbar
from IPython.core.pylabtools import figsize
from matplotlib.ticker import PercentFormatter
import matplotlib.ticker as mtick
import scipy.stats #import norm
from scipy.optimize import curve_fit
from google.colab import files
from statistics import mean, stdev

from google.colab import drive

file_path="/content/gdrive/My Drive/Colab Notebooks/W2_16nMExo_20X_001.csv"

drive.mount('/content/gdrive', force_remount=True)
open(file_path).read()

"""# **Data preparation**"""

# making dataframe
data = pd.read_csv(file_path)

#data # for diagnostic

# create a numpy array with only the columns of interest

array=data[['Trajectory','Frame','x','y']].to_numpy(dtype=object)  #For a mix of numeric and non-numeric types, the output array will have object dtype.

#print(array)

rows, columns = array.shape  # this gives the # rows and columns of the array
num_init=array[rows-1,0]

print(f"The number of beads tracked in ImageJ is {num_init}.")

# retain only the beads with all 361 frames

# count n. frames for each bead
count_frames={}   # associative array/dictionary composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection.

for i in array[:,0]:
    if i in count_frames:
        count_frames[i] +=1
    else:
        count_frames[i] =1

#print(count_frames)   # for diagnostic

maxframes= 361

filtered=[]

for n in count_frames.keys():       # dictionary.keys() gives the list of keys/items in the dictionary; in our case, it's the list of PARTICLE #
    if count_frames[n]==maxframes:
        filtered.append(n)


#print(filtered)  # (for diagnostic) it lists particle# that have the whole set of 361 frames

num_filt=len(filtered)
print(f"The number of particles that have the whole set of 361 frames is {num_filt}.")

# create a new array with only the beads having 361 frames

filter_arr=[]   # Create empty array with True or False

for element in range (0,rows):

    if array[element,0] in filtered:
        filter_arr.append(True)
    else:
        filter_arr.append(False)


#print(filter_arr)

newarray=array[filter_arr]

#print(newarray) # filtered array
#print(len(newarray)) # for diagnostic

# use only the first 300 beads
num_beads=300

cut_array=newarray[0:num_beads*361,:]     # 108300 is the n. of frames for the first 300 beads
tot=len(cut_array)

"""# **Custom Trajectory Selection**"""

# Filter out which Bead Trajectory you want
TrajectoryID=2

num_beads_start=TrajectoryID-1
cut_array=newarray[num_beads_start*361:TrajectoryID*361,:]     # 108300 is the n. of frames for the first 300 beads
print(cut_array)
tot=len(cut_array)
#print(l)

"""# **Threshold**"""

# zeroing the trajectories so that they all start from the center of the plot
zero_arr=np.zeros(cut_array.shape,dtype=object)
zero_arr[:,0]=cut_array[:,0]
zero_arr[:,1]=cut_array[:,1]

# zero, convert to microns
for element in range(0,tot):
  if cut_array[element,1]==0:     # if this is the 1st frame for a bead
    start=element
    deltax=0-cut_array[element,2] # x distance from the origin
    deltay=0-cut_array[element,3] # y distance from the origin

  zero_arr[element,2]=(cut_array[element,2]+deltax)*0.55  # change x
  zero_arr[element,3]=(cut_array[element,3]+deltay)*0.55  # change y

# inputs
upper_or_lower="upper"
threshold_value=200
#threshold_value=4.7
num_frames=361

# recalculate
num_beads=int(len(zero_arr)/num_frames)
tot=len(zero_arr)

# function
list_net_displ=[]

for element in range(0,tot):
  if zero_arr[element,1]==0:     # 1st frame for a bead
    initial_x=zero_arr[element,2]
    initial_y=zero_arr[element,3]

  if zero_arr[element,1]==num_frames-1:   # last frame for a bead
    final_x=zero_arr[element,2]
    final_y=zero_arr[element,3]
    net_d=np.sqrt((final_x - initial_x)**2 + (final_y - initial_y)**2)

    traj_n=zero_arr[element,0]
    list_net_displ.append([int(traj_n),net_d])

# filter according to the criteria provided and create a list of traj# respecting it
keep=[]

if upper_or_lower=='upper':
  for i in range (0,num_beads):
    if list_net_displ[i][1] <=threshold_value:
        keep.append(True)
    else:
        keep.append(False)

if upper_or_lower=='lower':
  for i in range (0,num_beads):
    if list_net_displ[i][1] >=threshold_value:
        keep.append(True)
    else:
        keep.append(False)

list_net_displ=np.array(list_net_displ, dtype=float)
filt_traj=list_net_displ[keep]

# create a zero_arr based on traj#
filt_traj=np.array(filt_traj, dtype=float)
list_traj=filt_traj[:,0]

tokeep=[]

for element in range (0,tot):
    if zero_arr[element,0] in list_traj:
      tokeep.append(True)
    else:
      tokeep.append(False)

filter_array=zero_arr[tokeep]
zero_arr=filter_array

"""# **Medusa plot (Line)**"""

# recalculate
tot=len(zero_arr)
num_beads=int(len(zero_arr)/num_frames)

# fig settings
frame_i=np.arange(0,1805/60,5/60)  # assign the time to the frame#
fig, ax = plt.subplots(figsize=(12,10))
plt.axis([-.3, .3, -.3, .3])
# Create a continuous norm to map from data points to colors
norm = plt.Normalize(frame_i.min(), frame_i.max())

# zero, convert to microns and plot
for element in range(0,tot):
  if filter_array[element,1]==0:     # if this is the 1st frame for a bead
    start=element

  if element==start+360:
    x=filter_array[start:element,2]
    y=filter_array[start:element,3]
    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)

    trajectory = LineCollection(segments, cmap="jet", norm=norm, linewidth=2, alpha=1, linestyles='solid')
    line = ax.add_collection(trajectory)
    #set the colour according to the time frame data
    trajectory.set_array(frame_i)
    #plt.plot(zero_arr[start:element,2], zero_arr[start:element,3]) # for diagnostic

cbar=fig.colorbar(trajectory, ax=ax)
#plt.title(f"Particles n={num_beads}", fontsize=20)
cbar.set_label("Time (min)",fontsize=20)
cbar.ax.tick_params(labelsize=26)

plt.xlabel("x position (μm)", fontsize=32)
plt.ylabel("y position (μm)", fontsize=32)
plt.setp(ax.get_xticklabels(), fontsize=24)
plt.setp(ax.get_yticklabels(), fontsize=24)

plt.grid(True, linewidth=1)
plt.show()

"""# **Run all statistics**

This will run all of the previous statistics (total disp, net disp, alpha) in one run without exporting files
"""

# total distance travelled
distance=[]

for element in range(0,tot):
  if zero_arr[element,1]==0:     # 1st frame for a bead
    d=0

  else:
    delta=np.sqrt((zero_arr[element,2] - zero_arr[element-1,2])**2 + (zero_arr[element,3] - zero_arr[element-1,3])**2)
    d=d+delta

  if zero_arr[element,1]==360:   # last frame for a bead
    distance.append(d)

#print(distance)
#print(len(distance))
mean=np. average(distance, axis=0)

print(f"The mean distance traveled is {round(mean,3)} μm")

fig, ax = plt.subplots(figsize=(9,8))

ax = sns.boxplot(y=distance,palette="GnBu",saturation=0.5, width=0.4)
sns.swarmplot(y=distance,color=".25")

plt.ylabel("Distance Traveled (μm)", fontsize=20)
plt.setp(ax.get_yticklabels(), fontsize=16)

#ax.set_title(f'Particle Displacement n={num_beads}', fontsize=20)
ax.set_title(f'Particle Displacement n={num_beads}', fontsize=20)

#ax.set(ylim=(0, 10))
ax.autoscale()
plt.grid()

# net displacement

net_displ=[]

for element in range(0,tot):
  if zero_arr[element,1]==0:     # 1st frame for a bead
    initial_x=zero_arr[element,2]
    initial_y=zero_arr[element,3]

  if zero_arr[element,1]==360:   # last frame for a bead
    final_x=zero_arr[element,2]
    final_y=zero_arr[element,3]
    net_d=np.sqrt((final_x - initial_x)**2 + (final_y - initial_y)**2)
    net_displ.append(net_d)

#print(net_displ)
#print(len(net_displ))
mean=np. average(net_displ, axis=0)

print(f"The mean net displacement is {round(mean,3)} μm")

fig, ax = plt.subplots(figsize=(9,8))

ax = sns.boxplot(y=net_displ,palette="GnBu",saturation=0.5, width=0.4)
sns.swarmplot(y=net_displ, color=".25")

plt.ylabel( "Net displacement (μm)", fontsize=20)
plt.setp(ax.get_yticklabels(), fontsize=16)

#ax.set_title(f'Particle Displacement n={num_beads}', fontsize=20)
ax.set_title(f'Mean net displacement = {round(mean,3)} μm', fontsize=20)
ax.autoscale()
plt.grid()

# Alpha value for initial 20% of timelapse
num_frames=361
use_frames=72

# variables
tot=len(zero_arr)
num_beads=int(tot/num_frames)
lagtime= range(1,num_frames)  #expressed in #frames, lag times=5s, 10s, 15s, etc
lagtime_s=np.linspace(5,num_frames*5,num_frames-1) # lagtime in seconds

split_arr=[]  # array of particle trajectories (arrays of x, y positions)
alpha_list=[] # it collects the alpha lists for each particle/trajectory

for element in range (0,tot):
  if zero_arr[element,1]==0:
    single_traj=zero_arr[element:element+num_frames,:]
    split_arr.append(single_traj)

for bead in range (0,num_beads):
  one_traj=split_arr[bead]
  msd_1traj=[]       # it contains the msd at each lag time for a single traj
  for i in lagtime:
    sd_list=[]

    for j in range(0,num_frames-i):
      sd=(one_traj[j+i,2]-one_traj[j,2])**2 + (one_traj[j+i,3]-one_traj[j,3])**2 # column 2 contains x coord, col 3 contains y coord
      sd_list.append(sd)

    avg_sd=np.mean(sd_list)  # msd at a lag time for a single traj
    msd_1traj.append(avg_sd)

  x=np.log(lagtime_s[0:use_frames])
  y=np.log(msd_1traj[0:use_frames])

  m, b = np.polyfit(x,y, 1)
  alpha_list.append(m)


# plot
num_beads=int(len(alpha_list))
mean=np. average(alpha_list, axis=0)

print(f"The mean alpha value is {round(mean,3)}")

fig, ax = plt.subplots(figsize=(9,8))

ax = sns.boxplot(y=alpha_list,palette="Oranges",saturation=0.65, width=0.4, linewidth=2,notch=True)
sns.swarmplot(y=alpha_list, marker="o", alpha=0.7,color=".25")

plt.ylabel('Alpha values', fontsize=20)
plt.setp(ax.get_yticklabels(), fontsize=16)
#ax.set_title(f'n={num_beads}', fontsize=20)
ax.set_title(f'Mean alpha value (20%) = {mean}', fontsize=20)
ax.autoscale()
plt.grid()

# Alpha value for whole timelapse
num_frames=361
use_frames=361

# variables
tot=len(zero_arr)
num_beads=int(tot/num_frames)
lagtime= range(1,num_frames)  #expressed in #frames, lag times=5s, 10s, 15s, etc
lagtime_s=np.linspace(5,num_frames*5,num_frames-1) # lagtime in seconds

split_arr=[]  # array of particle trajectories (arrays of x, y positions)
alpha_list_full=[] # it collects the alpha lists for each particle/trajectory

for element in range (0,tot):
  if zero_arr[element,1]==0:
    single_traj=zero_arr[element:element+num_frames,:]
    split_arr.append(single_traj)

for bead in range (0,num_beads):
  one_traj=split_arr[bead]
  msd_1traj=[]       # it contains the msd at each lag time for a single traj
  for i in lagtime:
    sd_list=[]

    for j in range(0,num_frames-i):
      sd=(one_traj[j+i,2]-one_traj[j,2])**2 + (one_traj[j+i,3]-one_traj[j,3])**2 # column 2 contains x coord, col 3 contains y coord
      sd_list.append(sd)

    avg_sd=np.mean(sd_list)  # msd at a lag time for a single traj
    msd_1traj.append(avg_sd)

  x=np.log(lagtime_s[0:use_frames])
  y=np.log(msd_1traj[0:use_frames])

  m, b = np.polyfit(x,y, 1)
  alpha_list_full.append(m)


# plot
num_beads=int(len(alpha_list_full))
mean=np. average(alpha_list_full, axis=0)

print(f"The mean alpha value is {round(mean,3)}")

fig, ax = plt.subplots(figsize=(9,8))

ax = sns.boxplot(y=alpha_list_full,palette="Oranges",saturation=0.65, width=0.4, linewidth=2,notch=True)
sns.swarmplot(y=alpha_list_full, marker="o", alpha=0.7,color=".25")

plt.ylabel('Alpha values', fontsize=20)
plt.setp(ax.get_yticklabels(), fontsize=16)
ax.set_title(f'n={num_beads}', fontsize=20)
ax.set_title(f'Mean alpha value (100%) = {round(mean,3)}', fontsize=20)
ax.autoscale()
plt.grid()

"""# **Statistics Export**"""

#This will create a dataframe to compile all of the desired statistics associated with each bead/motor in the timelapse. We can use this to further filter out unwanted motors
# Create an empty DataFrame
bead_data = pd.DataFrame(columns=['Bead_ID', 'Total Displacement', 'Net_Displacement', 'Alpha (100%)', 'Alpha (20%)'])

# Iterate over the lists and assign values row by row
for i in range(len(distance)):
    bead_data.loc[i] = [i + 1, distance[i], net_displ[i], alpha_list_full[i], alpha_list[i]]

# Display the DataFrame
print(bead_data)

# export csv file
# choose file name
file_name="output_AllStats_W3_10e3_2C-FAM_16nMexoIII.csv"

output = bead_data

output.to_csv(file_name)
files.download(file_name) #remove the comment symbol to download

"""#**Step size calculation**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Extract bead IDs, frame numbers, and positions from zero_arr
bead_ids = zero_arr[:, 0]  # Extract bead IDs
frames = zero_arr[:, 1]    # Extract frame numbers
x_positions = zero_arr[:, 2] * 1000  # Convert x-coordinates to nm
y_positions = zero_arr[:, 3] * 1000  # Convert y-coordinates to nm

# Create a DataFrame for easy manipulation
data = pd.DataFrame({
    "bead_id": bead_ids,
    "frame_number": frames,
    "x": x_positions,
    "y": y_positions
})

# Ensure the data is sorted by bead_id and frame_number
data = data.sort_values(by=["bead_id", "frame_number"])

# Compute step sizes (net displacement between frames)
step_sizes = []

# Loop through each unique bead_id (trajectory)
for bead_id in np.unique(bead_ids):
    bead_data = data[data["bead_id"] == bead_id].copy()

    # Convert to NumPy arrays
    x_vals = np.array(bead_data["x"].values, dtype=np.float64)
    y_vals = np.array(bead_data["y"].values, dtype=np.float64)

    # Compute displacement between consecutive frames
    dx = np.diff(x_vals)
    dy = np.diff(y_vals)
    displacement = np.sqrt(dx**2 + dy**2)  # Euclidean distance

    # Store step sizes
    step_sizes.extend(displacement.tolist())

# Convert step sizes to a NumPy array
step_sizes = np.array(step_sizes)

# Print summary statistics for validation
print(f"Total steps calculated: {len(step_sizes)}")
print(f"Mean step size: {np.mean(step_sizes):.3f} nm")
print(f"Standard deviation: {np.std(step_sizes):.3f} nm")

# Save step sizes to a CSV file for further analysis
output_file = "calculated_step_sizes_nm_W3.csv"
pd.DataFrame(step_sizes, columns=["step_size_nm"]).to_csv(output_file, index=False)
print(f"Step sizes saved to {output_file}")

# Define bins for the histogram
num_bins = 30  # Adjust for better resolution
bin_limit = 400#np.max(step_sizes)  # Set the max value dynamically

# Create histogram
plt.figure(figsize=(8, 6))
plt.hist(step_sizes, bins=np.linspace(0, bin_limit, num_bins), density=True, alpha=0.7, edgecolor='black', color='purple')

# Labels and formatting
plt.xlabel("Step Size (nm)", fontsize=16)
plt.ylabel("Probability Density", fontsize=16)
plt.title("Distribution of Calculated Step Sizes (in nm)", fontsize=18)
plt.grid(True, linestyle="--", linewidth=0.5)

# Show the plot
plt.show()

files.download(output_file) #remove the comment symbol to download

"""# **Instantaneous angle change**

This calculates inst. angle change *from the origin point, not between data points

Negative value of angle means motor is turning clockwise from origin point
Positive value of angle means motors are turning anti-clockwise from origin point

Angle values close to 0* means motors are not turning much, meaning they are moving fairly straight without much. No bending or sharp turning

Dot variable:

A = [Ax, Ay]
B = [Bx, By]

Dot: A · B = Ax * Bx + Ay * By

Just dot by itself will give that product, but cross variable adds left/right dimensions
"""

import numpy as np

def calculate_signed_angle_from_origin(trajectory_data):
    """
    Calculates the signed angle (in degrees) between vectors from the origin
    to trajectory points i and i+2 in a zero-centered trajectory.
    Returns angles from -180° to +180°.
    """
    angles = []
    origin = np.array([0, 0])

    for i in range(len(trajectory_data) - 2):
        p1 = trajectory_data[i]
        p2 = trajectory_data[i + 2]

        v1 = p1 - origin
        v2 = p2 - origin

        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)

        if norm_v1 == 0 or norm_v2 == 0:
            angles.append(np.nan)
            continue

        dot = np.dot(v1, v2)
        cross = v1[0]*v2[1] - v1[1]*v2[0]  # manual 2D cross product
        angle_rad = np.arctan2(cross, dot)
        angle_deg = np.degrees(angle_rad)

        angles.append(angle_deg)

    return np.array(angles)

# Run on your data
trajectory_data = zero_arr[:, 2:4]  # extract x and y columns
signed_angles = calculate_signed_angle_from_origin(trajectory_data)
signed_angles = signed_angles[~np.isnan(signed_angles)]

import matplotlib.pyplot as plt

# Example usage:
# trajectory_data = zero_arr[:, 2:4]
# signed_angles = calculate_signed_angle_from_origin(trajectory_data)
# signed_angles = signed_angles[~np.isnan(signed_angles)]

# --- Histogram Plot ---
plt.figure(figsize=(8, 5))
plt.hist(signed_angles, bins=36, color='steelblue', edgecolor='black')
plt.title("Histogram of Signed Angles from Origin")
plt.xlabel("Angle (degrees)")
plt.ylabel("Frequency")
plt.xlim([-180, 180])
plt.grid(True)
plt.tight_layout()
plt.show()

# --- Polar Plot ---
signed_angles_rad = np.radians(signed_angles)
plt.figure(figsize=(6, 6))
ax = plt.subplot(111, polar=True)
ax.hist(signed_angles_rad, bins=36, color='mediumseagreen', edgecolor='black')
ax.set_theta_zero_location("N")
ax.set_theta_direction(-1)
ax.set_title("Polar Plot of Signed Angles", va='bottom')
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Angle calculation functions ---
def calculate_stepwise_turning_angles(trajectory_data):
    angles = []
    for i in range(len(trajectory_data) - 2):
        v1 = trajectory_data[i + 1] - trajectory_data[i]
        v2 = trajectory_data[i + 2] - trajectory_data[i + 1]

        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)
        if norm_v1 == 0 or norm_v2 == 0:
            angles.append(np.nan)
            continue

        dot = np.dot(v1, v2)
        cross = v1[0]*v2[1] - v1[1]*v2[0]
        angle_rad = np.arctan2(cross, dot)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

def calculate_angle_from_origin_over_time(trajectory_data):
    angles = []
    for x, y in trajectory_data:
        angle_rad = np.arctan2(y, x)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

# --- Load and select first bead ---
# Make sure zero_arr is already defined
unique_beads = np.unique(zero_arr[:, 0])
bead_id = unique_beads[0]
bead_data = zero_arr[zero_arr[:, 0] == bead_id]
trajectory_data = bead_data[:, 2:4]

# --- Calculate angles ---
stepwise_turning_angles = calculate_stepwise_turning_angles(trajectory_data)
stepwise_turning_angles = stepwise_turning_angles[~np.isnan(stepwise_turning_angles)]
origin_angles = calculate_angle_from_origin_over_time(trajectory_data)

# --- Convert frame index to time in minutes (0.2 Hz = 1 frame every 5 seconds) ---
frame_count = len(origin_angles)
time_minutes = np.arange(frame_count) * (5 / 60)

# --- Plot 1: Step-to-step turning angle histogram ---
plt.figure(figsize=(8, 5))
plt.hist(stepwise_turning_angles, bins=36, color='darkorange', edgecolor='black')
plt.title(f"Step-to-Step Turning Angle Histogram (Bead {int(bead_id)})")
plt.xlabel("Turning Angle (degrees)")
plt.ylabel("Frequency")
plt.xlim([-180, 180])
plt.grid(True)
plt.tight_layout()
plt.show()

# --- Plot 2: Angle from origin over time ---
plt.figure(figsize=(10, 4))
plt.plot(time_minutes, origin_angles, color='navy', linewidth=1)
plt.title(f"Angle from Origin Over Time (Bead {int(bead_id)})")
plt.xlabel("Time (minutes)")
plt.ylabel("Angle (degrees)")
plt.grid(True)
plt.tight_layout()
plt.show()

# --- Calculate instantaneous angle change (degrees/frame) ---
def calculate_instantaneous_angle_change(origin_angles):
    delta_angles = np.diff(origin_angles)

    # Wrap to [-180, 180] range
    delta_angles = (delta_angles + 180) % 360 - 180

    return delta_angles

# --- Compute from previously calculated origin_angles ---
instantaneous_angle_changes = calculate_instantaneous_angle_change(origin_angles)

# --- Trim time axis since diff reduces length by 1 ---
time_minutes_diff = time_minutes[:-1]

# --- Plot instantaneous angle change over time ---
plt.figure(figsize=(10, 4))
plt.plot(time_minutes_diff, instantaneous_angle_changes, color='crimson', linewidth=1)
plt.title(f"Instantaneous Angle Change Over Time (Bead {int(bead_id)})")
plt.xlabel("Time (minutes)")
plt.ylabel("ΔAngle (degrees)")
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Functions ---
def calculate_angle_from_origin_over_time(trajectory_data):
    angles = []
    for x, y in trajectory_data:
        angle_rad = np.arctan2(y, x)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

def calculate_instantaneous_angle_change(origin_angles):
    delta_angles = np.diff(origin_angles)
    delta_angles = (delta_angles + 180) % 360 - 180  # wrap to [-180, 180]
    return delta_angles

# --- SELECT YOUR BEAD HERE ---
# Get all bead IDs
bead_ids = np.unique(zero_arr[:, 0])
# Select bead index: 0 = first bead, 1 = second bead, etc.
bead_index = 0
bead_id = bead_ids[bead_index]

# Extract trajectory data for this bead
bead_data = zero_arr[zero_arr[:, 0] == bead_id]
trajectory_data = bead_data[:, 2:4]  # use only x and y

# --- Compute angles ---
origin_angles = calculate_angle_from_origin_over_time(trajectory_data)
instantaneous_angle_changes = calculate_instantaneous_angle_change(origin_angles)

# Time axis (0.2 Hz sampling = 1 frame every 5 sec)
frame_count = len(origin_angles)
time_minutes = np.arange(frame_count) * (5 / 60)
time_minutes_trimmed = time_minutes[:-1]  # for instantaneous angle diff

# --- Plot ---
fig, axs = plt.subplots(2, 1, figsize=(12, 6), sharex=True, gridspec_kw={'height_ratios': [2, 1]})

# Top: angle from origin
axs[0].plot(time_minutes, origin_angles, color='navy')
axs[0].set_ylabel("Angle from Origin (°)")
axs[0].set_title(f"Bead {int(bead_id)}: Angle and Instantaneous Change Over Time")
axs[0].grid(True)

# Bottom: ΔAngle over time
axs[1].plot(time_minutes_trimmed, instantaneous_angle_changes, color='crimson')
axs[1].set_ylabel("ΔAngle (°/frame)")
axs[1].set_xlabel("Time (minutes)")
axs[1].grid(True)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Functions ---
def calculate_angle_from_origin_over_time(trajectory_data):
    angles = []
    for x, y in trajectory_data:
        angle_rad = np.arctan2(y, x)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

def calculate_instantaneous_angle_change(origin_angles):
    delta_angles = np.diff(origin_angles)
    delta_angles = (delta_angles + 180) % 360 - 180  # wrap to [-180, 180]
    return delta_angles

# --- Get unique bead IDs ---
bead_ids = np.unique(zero_arr[:, 0])
num_beads = len(bead_ids)

# --- Storage for all bead traces ---
angles_all = []
delta_angles_all = []

for bead_id in bead_ids:
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    trajectory_data = bead_data[:, 2:4]

    origin_angles = calculate_angle_from_origin_over_time(trajectory_data)
    instantaneous_angle_changes = calculate_instantaneous_angle_change(origin_angles)

    angles_all.append(origin_angles)
    delta_angles_all.append(instantaneous_angle_changes)

# Convert to NumPy arrays
angles_all = np.array(angles_all)
delta_angles_all = np.array(delta_angles_all)

# Time vectors
num_frames = angles_all.shape[1]
time_minutes = np.arange(num_frames) * (5 / 60)
time_minutes_trimmed = time_minutes[:-1]

# --- Compute Mean and Std ---
mean_angles = np.nanmean(angles_all, axis=0)
std_angles = np.nanstd(angles_all, axis=0)

mean_delta_angles = np.nanmean(delta_angles_all, axis=0)
std_delta_angles = np.nanstd(delta_angles_all, axis=0)

# --- Plot ---
fig, axs = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

# Top plot: Angle from Origin
axs[0].plot(time_minutes, mean_angles, color='navy', linewidth=3, label='Mean')
axs[0].fill_between(time_minutes, mean_angles - std_angles, mean_angles + std_angles,
                    color='gray', alpha=0.4, label='±1 SD')
axs[0].set_ylabel("Angle from Origin (°)", fontsize=16)
axs[0].set_title("Mean Angle from Origin with ±1 SD", fontsize=18)
axs[0].legend(fontsize=12)
axs[0].grid(True)

# Bottom plot: ΔAngle over time
axs[1].plot(time_minutes_trimmed, mean_delta_angles, color='crimson', linewidth=3, label='Mean')
axs[1].fill_between(time_minutes_trimmed, mean_delta_angles - std_delta_angles, mean_delta_angles + std_delta_angles,
                    color='gray', alpha=0.4, label='±1 SD')
axs[1].set_ylabel("ΔAngle (°/frame)", fontsize=16)
axs[1].set_xlabel("Time (minutes)", fontsize=16)
axs[1].set_title("Mean Instantaneous Angle Change with ±1 SD", fontsize=18)
axs[1].legend(fontsize=12)
axs[1].grid(True)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Functions ---
def calculate_angle_from_origin_over_time(trajectory_data):
    angles = []
    for x, y in trajectory_data:
        angle_rad = np.arctan2(y, x)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

def calculate_instantaneous_angle_change(origin_angles):
    delta_angles = np.diff(origin_angles)
    delta_angles = (delta_angles + 180) % 360 - 180  # wrap to [-180, 180]
    return delta_angles

# --- Get first 5 unique bead IDs ---
bead_ids = np.unique(zero_arr[:, 0])[:5]

# --- Plot setup ---
fig, axs = plt.subplots(2, 1, figsize=(14, 6), sharex=True, gridspec_kw={'height_ratios': [2, 1]})
colors = plt.cm.tab10(np.linspace(0, 1, len(bead_ids)))  # distinct colors

for i, bead_id in enumerate(bead_ids):
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    trajectory_data = bead_data[:, 2:4]

    origin_angles = calculate_angle_from_origin_over_time(trajectory_data)
    instantaneous_angle_changes = calculate_instantaneous_angle_change(origin_angles)

    frame_count = len(origin_angles)
    time_minutes = np.arange(frame_count) * (5 / 60)
    time_minutes_trimmed = time_minutes[:-1]

    # Plot angle from origin
    axs[0].plot(time_minutes, origin_angles, label=f'Bead {int(bead_id)}', color=colors[i])
    # Plot instantaneous angle change
    axs[1].plot(time_minutes_trimmed, instantaneous_angle_changes, label=f'Bead {int(bead_id)}', color=colors[i])

# --- Axis formatting ---
axs[0].set_ylabel("Angle from Origin (°)")
axs[0].set_title("Angles and Instantaneous Changes for 5 Beads")
axs[0].grid(True)

axs[1].set_ylabel("ΔAngle (°/frame)")
axs[1].set_xlabel("Time (minutes)")
axs[1].grid(True)

# --- Move legends outside ---
for ax in axs:
    ax.legend(loc='center left', bbox_to_anchor=(1.01, 0.5), fontsize=10)

plt.tight_layout(rect=[0, 0, 0.85, 1])  # leave space on right for legends
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Functions ---
def calculate_angle_from_origin_over_time(trajectory_data):
    angles = []
    for x, y in trajectory_data:
        angle_rad = np.arctan2(y, x)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

def calculate_instantaneous_angle_change(origin_angles):
    delta_angles = np.diff(origin_angles)
    delta_angles = (delta_angles + 180) % 360 - 180  # wrap to [-180, 180]
    return delta_angles

# --- Get 5 random bead IDs ---
np.random.seed(3)  # for reproducibility, remove or change for different results
bead_ids = np.random.choice(np.unique(zero_arr[:, 0]), size=5, replace=False)

# --- Plot setup ---
fig, axs = plt.subplots(2, 1, figsize=(14, 6), sharex=True, gridspec_kw={'height_ratios': [2, 1]})
colors = plt.cm.tab10(np.linspace(0, 1, len(bead_ids)))  # distinct colors

for i, bead_id in enumerate(bead_ids):
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    trajectory_data = bead_data[:, 2:4]

    origin_angles = calculate_angle_from_origin_over_time(trajectory_data)
    instantaneous_angle_changes = calculate_instantaneous_angle_change(origin_angles)

    frame_count = len(origin_angles)
    time_minutes = np.arange(frame_count) * (5 / 60)
    time_minutes_trimmed = time_minutes[:-1]

    # Plot angle from origin
    axs[0].plot(time_minutes, origin_angles, label=f'Bead {int(bead_id)}', color=colors[i])
    # Plot instantaneous angle change
    axs[1].plot(time_minutes_trimmed, instantaneous_angle_changes, label=f'Bead {int(bead_id)}', color=colors[i])

# --- Axis formatting ---
axs[0].set_ylabel("Angle from Origin (°)")
axs[0].set_title("Angles and Instantaneous Changes for 5 Random Beads")
axs[0].grid(True)

axs[1].set_ylabel("ΔAngle (°/frame)")
axs[1].set_xlabel("Time (minutes)")
axs[1].grid(True)

# --- Move legends outside the plot area ---
for ax in axs:
    ax.legend(loc='center left', bbox_to_anchor=(1.01, 0.5), fontsize=10)

plt.tight_layout(rect=[0, 0, 0.85, 1])  # leave space on right for legends
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- 1. Function to calculate local motion angle (angle of velocity vector) ---
def calculate_local_motion_angle(trajectory_data):
    angles = []
    for i in range(len(trajectory_data) - 1):
        dx, dy = trajectory_data[i + 1] - trajectory_data[i]
        angle_rad = np.arctan2(dy, dx)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

# --- 2. Select bead ---
bead_ids = np.unique(zero_arr[:, 0])
bead_index = 0  # change this to select another bead (e.g., 1 for second bead)
bead_id = bead_ids[bead_index]

bead_data = zero_arr[zero_arr[:, 0] == bead_id]
trajectory_data = bead_data[:, 2:4]

# --- 3. Compute motion angle + time axis ---
local_motion_angles = calculate_local_motion_angle(trajectory_data)
frame_count = len(local_motion_angles)
time_minutes_local = np.arange(frame_count) * (5 / 60)  # assuming 0.2 Hz (5 sec per frame)

# --- 4. Plot ---
plt.figure(figsize=(10, 4))
plt.plot(time_minutes_local, local_motion_angles, color='darkgreen', linewidth=1)
plt.title(f"Local Motion Direction Angle Over Time (Bead {int(bead_id)})")
plt.xlabel("Time (minutes)")
plt.ylabel("Local Motion Angle (° from x-axis)")
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Functions ---
def calculate_angle_from_origin_over_time(trajectory_data):
    angles = []
    for x, y in trajectory_data:
        angle_rad = np.arctan2(y, x)
        angle_deg = np.degrees(angle_rad)
        angles.append(angle_deg)
    return np.array(angles)

def calculate_instantaneous_angle_change(origin_angles):
    delta_angles = np.diff(origin_angles)
    delta_angles = (delta_angles + 180) % 360 - 180
    return delta_angles

def calculate_velocity(trajectory_data, time_interval_minutes):
    trajectory_data = np.array(trajectory_data, dtype=float)  # Force into clean float array
    diffs = np.diff(trajectory_data, axis=0)
    distances = np.linalg.norm(diffs, axis=1)
    velocities = distances / time_interval_minutes
    return velocities


# --- Setup ---
np.random.seed(1)
bead_ids = np.random.choice(np.unique(zero_arr[:, 0]), size=5, replace=False)
colors = plt.cm.tab10(np.linspace(0, 1, len(bead_ids)))
time_interval_minutes = 5 / 60  # 5 sec = 0.0833 min

# --- Plot setup ---
fig, axs = plt.subplots(len(bead_ids), 1, figsize=(14, 3 * len(bead_ids)), sharex=True)

if len(bead_ids) == 1:
    axs = [axs]  # Make iterable if only one bead

for i, bead_id in enumerate(bead_ids):
    ax = axs[i]
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    trajectory_data = bead_data[:, 2:4]

    # Compute values
    origin_angles = calculate_angle_from_origin_over_time(trajectory_data)
    velocities = calculate_velocity(trajectory_data, time_interval_minutes)

    # Time arrays
    time_minutes = np.arange(len(origin_angles)) * time_interval_minutes
    time_minutes_v = time_minutes[1:]  # velocity is 1 shorter than angles

    # Plot angle (left y-axis)
    ax.plot(time_minutes, origin_angles, color=colors[i], label=f'Angle (Bead {int(bead_id)})', linewidth=2)
    ax.set_ylabel("Angle (°)", fontsize=12, color=colors[i])
    ax.tick_params(axis='y', labelcolor=colors[i])
    ax.grid(True)

    # Plot velocity (right y-axis)
    ax2 = ax.twinx()
    ax2.plot(time_minutes_v, velocities, color='gray', linestyle='--', label='Velocity', linewidth=2)
    ax2.set_ylabel("Velocity (μm/min)", fontsize=12, color='gray')
    ax2.tick_params(axis='y', labelcolor='gray')

    ax.set_title(f"Bead {int(bead_id)}: Angle vs Velocity", fontsize=14)

# Shared x-axis
axs[-1].set_xlabel("Time (minutes)", fontsize=14)

plt.tight_layout()
plt.show()

"""# **Inst. Turning Angle**"""

import numpy as np
import matplotlib.pyplot as plt

# --- Select Bead ---
bead_ids = np.unique(zero_arr[:, 0])
bead_index = 2  # ← Change this to pick a different bead
bead_id = bead_ids[bead_index]

bead_data = zero_arr[zero_arr[:, 0] == bead_id]
trajectory_data = bead_data[:, 2:4]  # use only x and y

# --- Calculate turning angle between triplets of points ---
triplet_angles = []
triplet_centers = []

for i in range(len(trajectory_data) - 2):
    p0, p1, p2 = trajectory_data[i], trajectory_data[i + 1], trajectory_data[i + 2]
    v1 = p1 - p0
    v2 = p2 - p1

    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)

    if norm_v1 == 0 or norm_v2 == 0:
        angle_deg = np.nan
    else:
        dot = np.dot(v1, v2)
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        angle_rad = np.arctan2(cross, dot)
        angle_deg = np.degrees(angle_rad)

    triplet_angles.append(angle_deg)
    triplet_centers.append(p1)

# --- Plot ---
# --- Plot every 5th angle label ---
fig, ax = plt.subplots(figsize=(8, 7))
ax.plot(trajectory_data[:, 0], trajectory_data[:, 1], 'ko-', markersize=3, linewidth=1, label="Trajectory")

for i, (center, angle) in enumerate(zip(triplet_centers, triplet_angles)):
    if not np.isnan(angle) and i % 5 == 0:  # every 5th angle
        ax.text(center[0], center[1], f"{angle:.1f}°", fontsize=8, color='darkred', ha='center', va='center')

ax.set_title(f"Turning Angles (Every 5th Triplet, Bead {int(bead_id)})")
ax.set_xlabel("X Position (nm)")
ax.set_ylabel("Y Position (nm)")
ax.set_aspect('equal')
ax.grid(True)
ax.legend()
plt.tight_layout()
plt.show()

# --- Plot histogram of all triplet-based turning angles ---
angles_clean = np.array(triplet_angles)
angles_clean = angles_clean[~np.isnan(angles_clean)]  # remove NaNs

plt.figure(figsize=(8, 5))
plt.hist(angles_clean, bins=36, color='slateblue', edgecolor='black')
plt.title(f"Distribution of Triplet-Based Turning Angles (Bead {int(bead_id)})")
plt.xlabel("Turning Angle (degrees)")
plt.ylabel("Frequency")
plt.xlim([-180, 180])
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Parameters ---
dt = 5  # seconds between frames
speed_threshold = 1  # threshold in nm/min
label_step = 5        # label every nth triplet

# --- Recalculate turning angles and speed (in nm/min) ---
triplet_angles = []
triplet_centers = []
triplet_speeds = []

for i in range(len(trajectory_data) - 2):
    p0, p1, p2 = trajectory_data[i], trajectory_data[i + 1], trajectory_data[i + 2]
    v1 = p1 - p0
    v2 = p2 - p1

    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)

    if norm_v1 == 0 or norm_v2 == 0:
        angle_deg = np.nan
        speed = 0
    else:
        dot = np.dot(v1, v2)
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        angle_rad = np.arctan2(cross, dot)
        angle_deg = np.degrees(angle_rad)
        speed = (norm_v1 + norm_v2) / (2 * dt) * 60  # convert to nm/min

    triplet_angles.append(angle_deg)
    triplet_centers.append(p1)
    triplet_speeds.append(speed)

triplet_angles = np.array(triplet_angles)
triplet_speeds = np.array(triplet_speeds)
triplet_centers = np.array(triplet_centers)

# --- Trajectory Plot (Filtered) ---
fig, ax = plt.subplots(figsize=(9, 7))
ax.plot(trajectory_data[:, 0], trajectory_data[:, 1], 'ko-', markersize=3, linewidth=1, label="Trajectory")

for i, (center, angle, speed) in enumerate(zip(triplet_centers, triplet_angles, triplet_speeds)):
    if not np.isnan(angle) and speed > speed_threshold and i % label_step == 0:
        ax.text(center[0], center[1], f"{angle:.1f}°", fontsize=8, color='darkred', ha='center', va='center')

ax.set_title(f"Filtered Turning Angles (Speed > {speed_threshold} nm/min, Bead {int(bead_id)})")
ax.set_xlabel("X Position (nm)")
ax.set_ylabel("Y Position (nm)")
ax.set_aspect('equal')
ax.grid(True)
ax.legend()
plt.tight_layout()
plt.show()

# --- Turning Angle vs. Speed Scatter Plot ---
valid = ~np.isnan(triplet_angles)
angle_magnitude = np.abs(triplet_angles[valid])
speeds_filtered = triplet_speeds[valid]

plt.figure(figsize=(8, 5))
plt.scatter(speeds_filtered, angle_magnitude, alpha=0.6, c='purple')
plt.title(f"Turning Angle Magnitude vs Speed (Bead {int(bead_id)})")
plt.xlabel("Speed (nm/min)")
plt.ylabel("|Turning Angle| (degrees)")
plt.grid(True)
plt.tight_layout()
plt.show()

# --- Correlation between angle magnitude and speed ---
if len(speeds_filtered) > 1:
    corr_matrix = np.corrcoef(speeds_filtered, angle_magnitude)
    corr_value = corr_matrix[0, 1]
    print(f"Pearson correlation between speed and |angle|: {corr_value:.3f}")
else:
    print("Not enough valid points to compute correlation.")

import matplotlib.pyplot as plt
import numpy as np

# --- Time axis for triplet-based angles ---
dt = 5  # seconds between frames
time_axis_min = np.arange(1, len(triplet_angles) + 1) * (dt / 60)  # in minutes

# --- Filter NaNs ---
valid_mask = ~np.isnan(triplet_angles)
valid_angles = triplet_angles[valid_mask]
valid_times = time_axis_min[valid_mask]

# --- Plot ---
plt.figure(figsize=(10, 4))
plt.plot(valid_times, valid_angles, 'o-', color='teal', markersize=3)
plt.title(f"Turning Angle vs Time (Bead {int(bead_id)})")
plt.xlabel("Time (minutes)")
plt.ylabel("Turning Angle (degrees)")
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import numpy as np

# --- Prepare segment coordinates and angles ---
segment_points = []
colors = []

for i in range(len(triplet_angles)):
    if np.isnan(triplet_angles[i]):
        continue
    p1 = trajectory_data[i + 1]
    p2 = trajectory_data[i + 2]
    segment_points.append([p1, p2])
    colors.append(triplet_angles[i])

segment_points = np.array(segment_points)
colors = np.array(colors)

# --- Create colored line collection ---
cmap = plt.get_cmap('coolwarm')  # new colormap
norm = plt.Normalize(vmin=-180, vmax=180)

fig, ax = plt.subplots(figsize=(10, 5))  # better aspect ratio
line_segments = LineCollection(segment_points, array=colors, cmap=cmap, norm=norm, linewidth=2)
ax.add_collection(line_segments)

# Background path
ax.plot(trajectory_data[:, 0], trajectory_data[:, 1], 'k--', alpha=0.2)

# Labels and formatting
ax.set_title(f"Trajectory Colored by Turning Angle (Bead {int(bead_id)})")
ax.set_xlabel("X Position (nm)")
ax.set_ylabel("Y Position (nm)")
ax.set_aspect('auto')  # allow x/y to scale naturally
ax.grid(True)

# Colorbar
cbar = plt.colorbar(line_segments, ax=ax)
cbar.set_label("Turning Angle (degrees)")

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

# --- Global font scaling ---
plt.rcParams.update({
    'font.size': 18,
    'axes.labelsize': 42,
    'axes.titlesize': 46,
    'xtick.labelsize': 42,
    'ytick.labelsize': 42,
    'legend.fontsize': 16,
    'figure.titlesize': 24,
})

# --- Step 1: Recalculate triplet-based turning angles (0–360°) ---
triplet_angles = []
triplet_centers = []

for i in range(len(trajectory_data) - 2):
    p0, p1, p2 = trajectory_data[i], trajectory_data[i + 1], trajectory_data[i + 2]
    v1 = p1 - p0
    v2 = p2 - p1

    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)

    if norm_v1 == 0 or norm_v2 == 0:
        angle_deg = np.nan
    else:
        dot = np.dot(v1, v2)
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        angle_rad = np.arctan2(cross, dot)

        # Convert to 0–360° instead of -180–180°
        angle_deg = np.degrees(angle_rad)
        if angle_deg < 0:
            angle_deg += 360

    triplet_angles.append(angle_deg)
    triplet_centers.append(p1)

triplet_angles = np.array(triplet_angles)
triplet_centers = np.array(triplet_centers)

# --- Step 2: Create segments and color mapping ---
segment_points = []
colors = []

for i in range(len(triplet_angles)):
    if np.isnan(triplet_angles[i]):
        continue
    p1 = trajectory_data[i + 1]
    p2 = trajectory_data[i + 2]
    segment_points.append([p1, p2])
    colors.append(triplet_angles[i])

segment_points = np.array(segment_points)
colors = np.array(colors)

# --- Step 3: Plot trajectory with color-coded turning angles ---
fig, ax = plt.subplots(figsize=(9, 10))
cmap = plt.get_cmap('plasma')
norm = plt.Normalize(vmin=0, vmax=360)  # updated range for full rotation

line_segments = LineCollection(segment_points, array=colors, cmap=cmap, norm=norm, linewidth=3)
ax.add_collection(line_segments)

# Light trajectory background
ax.plot(trajectory_data[:, 0], trajectory_data[:, 1], 'k--', alpha=0.2)

# Formatting
#ax.set_title(f"Turning Angle", pad=15)
ax.set_xlabel("X Position (μm)")
ax.set_ylabel("Y Position (μm)")
ax.set_aspect('auto')
ax.grid(True, linestyle='--', alpha=0.5)

# --- Colorbar ---
cbar = plt.colorbar(line_segments, ax=ax)
cbar.set_label("Turning Angle (°)", fontsize=26, labelpad=15)
cbar.ax.tick_params(labelsize=26)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

# --- Setup ---
bead_ids = np.unique(zero_arr[:, 0])
n_beads = min(10, len(bead_ids))
fig, axes = plt.subplots(2, 5, figsize=(20, 8))
axes = axes.flatten()

for idx in range(n_beads):
    bead_id = bead_ids[idx]
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    trajectory_data = bead_data[:, 2:4]

    # --- Step 1: Calculate directionless triplet turning angles ---
    triplet_angles = []
    segment_points = []

    for i in range(len(trajectory_data) - 2):
        p0, p1, p2 = trajectory_data[i], trajectory_data[i + 1], trajectory_data[i + 2]
        v1 = p1 - p0
        v2 = p2 - p1

        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)

        if norm_v1 == 0 or norm_v2 == 0:
            continue

        dot = np.dot(v1, v2)
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        angle_rad = np.arctan2(cross, dot)
        angle_deg = abs(np.degrees(angle_rad))  # make directionless

        triplet_angles.append(angle_deg)
        segment_points.append([p1, p2])

    if not triplet_angles:
        continue

    triplet_angles = np.array(triplet_angles)
    segment_points = np.array(segment_points)

    # --- Step 2: Plot with plasma colormap ---
    ax = axes[idx]
    cmap = plt.get_cmap('plasma')
    norm = plt.Normalize(vmin=0, vmax=180)

    lc = LineCollection(segment_points, array=triplet_angles, cmap=cmap, norm=norm, linewidth=2)
    ax.add_collection(lc)

    ax.plot(trajectory_data[:, 0], trajectory_data[:, 1], 'k--', alpha=0.2)
    ax.set_title(f"Bead {int(bead_id)}")
    ax.set_aspect('auto')
    ax.set_xticks([])
    ax.set_yticks([])
    ax.grid(False)

# --- Shared colorbar ---
cbar_ax = fig.add_axes([0.92, 0.15, 0.015, 0.7])
sm = plt.cm.ScalarMappable(cmap='plasma', norm=plt.Normalize(vmin=0, vmax=180))
sm.set_array([])
cbar = fig.colorbar(sm, cax=cbar_ax)
cbar.set_label("Turning Angle (°)")

plt.suptitle("Directionless Turning Angle Colored Trajectories (First 10 Beads)", fontsize=16)
plt.tight_layout(rect=[0, 0, 0.9, 0.95])
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

# --- Setup ---
bead_ids = np.unique(zero_arr[:, 0])
n_beads = min(10, len(bead_ids))

# Randomly select bead IDs
np.random.seed(2)  # optional: for reproducibility
selected_ids = np.random.choice(bead_ids, size=n_beads, replace=False)

fig, axes = plt.subplots(2, 5, figsize=(20, 8))
axes = axes.flatten()

for idx, bead_id in enumerate(selected_ids):
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    trajectory_data = bead_data[:, 2:4]

    triplet_angles = []
    segment_points = []

    for i in range(len(trajectory_data) - 2):
        p0, p1, p2 = trajectory_data[i], trajectory_data[i + 1], trajectory_data[i + 2]
        v1 = p1 - p0
        v2 = p2 - p1

        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)

        if norm_v1 == 0 or norm_v2 == 0:
            continue

        dot = np.dot(v1, v2)
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        angle_rad = np.arctan2(cross, dot)
        angle_deg = abs(np.degrees(angle_rad))

        triplet_angles.append(angle_deg)
        segment_points.append([p1, p2])

    if not triplet_angles:
        continue

    triplet_angles = np.array(triplet_angles)
    segment_points = np.array(segment_points)

    ax = axes[idx]
    cmap = plt.get_cmap('plasma')
    norm = plt.Normalize(vmin=0, vmax=180)

    lc = LineCollection(segment_points, array=triplet_angles, cmap=cmap, norm=norm, linewidth=2)
    ax.add_collection(lc)

    ax.plot(trajectory_data[:, 0], trajectory_data[:, 1], 'k--', alpha=0.2)
    ax.set_title(f"Bead {int(bead_id)}")
    ax.set_aspect('auto')
    ax.set_xticks([])
    ax.set_yticks([])
    ax.grid(False)

# --- Shared colorbar ---
cbar_ax = fig.add_axes([0.92, 0.15, 0.015, 0.7])
sm = plt.cm.ScalarMappable(cmap='plasma', norm=plt.Normalize(vmin=0, vmax=180))
sm.set_array([])
cbar = fig.colorbar(sm, cax=cbar_ax)
cbar.set_label("Turning Angle (°)")

plt.suptitle("Directionless Turning Angle Colored Trajectories (10 Random Beads)", fontsize=16)
plt.tight_layout(rect=[0, 0, 0.9, 0.95])
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Parameters ---
dt = 5  # seconds between frames
speed_threshold = 2  # threshold in nm/min

# --- Initialize global lists ---
all_angles = []
all_speeds = []

# --- Loop through each bead ---
bead_ids = np.unique(zero_arr[:, 0])
for bead_id in bead_ids:
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    trajectory_data = bead_data[:, 2:4]

    for i in range(len(trajectory_data) - 2):
        p0, p1, p2 = trajectory_data[i], trajectory_data[i + 1], trajectory_data[i + 2]
        v1 = p1 - p0
        v2 = p2 - p1

        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)

        if norm_v1 == 0 or norm_v2 == 0:
            continue

        dot = np.dot(v1, v2)
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        angle_rad = np.arctan2(cross, dot)
        angle_deg = np.degrees(angle_rad)
        speed = (norm_v1 + norm_v2) / (2 * dt) * 60  # convert to nm/min

        all_angles.append(abs(angle_deg))  # directionless
        all_speeds.append(speed)

all_angles = np.array(all_angles)
all_speeds = np.array(all_speeds)

# --- Filter out NaNs if any ---
valid = ~np.isnan(all_angles)
angle_magnitude = all_angles[valid]
speeds_filtered = all_speeds[valid]

# --- Scatter Plot ---
plt.figure(figsize=(8, 5))
plt.scatter(speeds_filtered, angle_magnitude, alpha=0.4, c='purple', edgecolors='black', linewidth=0.3)
plt.title("Turning Angle Magnitude vs Speed (All Beads)")
plt.xlabel("Speed (nm/min)")
plt.ylabel("|Turning Angle| (degrees)")
#plt.xlim([2, 6])
plt.grid(True)
plt.tight_layout()
plt.show()

# --- Correlation ---
if len(speeds_filtered) > 1:
    corr_matrix = np.corrcoef(speeds_filtered, angle_magnitude)
    corr_value = corr_matrix[0, 1]
    print(f"Pearson correlation between speed and |angle|: {corr_value:.3f}")
else:
    print("Not enough valid points to compute correlation.")

plt.figure(figsize=(8, 5))
plt.hist2d(speeds_filtered, angle_magnitude, bins=[50, 50], cmap='viridis')
plt.xlim([2, 6])
plt.colorbar(label='Counts')
plt.xlabel("Speed (nm/min)")
plt.ylabel("|Turning Angle| (degrees)")
plt.title("Turning Angle vs Speed (2D Histogram)")
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Define speed bins
bin_edges = np.linspace(0, 10, 21)  # 0 to 10 nm/min, 20 bins
bin_centers = 0.5 * (bin_edges[:-1] + bin_edges[1:])
mean_angles = []
std_angles = []

for i in range(len(bin_edges) - 1):
    in_bin = (speeds_filtered >= bin_edges[i]) & (speeds_filtered < bin_edges[i+1])
    angles_in_bin = angle_magnitude[in_bin]
    if len(angles_in_bin) > 0:
        mean_angles.append(np.mean(angles_in_bin))
        std_angles.append(np.std(angles_in_bin))
    else:
        mean_angles.append(np.nan)
        std_angles.append(np.nan)

# Plot mean ± SD
plt.figure(figsize=(8, 5))
plt.errorbar(bin_centers, mean_angles, yerr=std_angles, fmt='o-', capsize=4, color='teal')
plt.title("Mean Turning Angle vs Speed (Binned)")
plt.xlabel("Speed (nm/min)")
plt.ylabel("Mean |Turning Angle| ± SD (degrees)")
plt.grid(True)
plt.tight_layout()
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# --- Bin speed into intervals ---
bin_edges = np.arange(0, 10.5, 1)  # 0-1, 1-2, ..., 9-10
bin_labels = [f"{int(b)}–{int(b+1)}" for b in bin_edges[:-1]]
speed_bin = pd.cut(speeds_filtered, bins=bin_edges, labels=bin_labels)

# --- Create DataFrame ---
df = pd.DataFrame({
    'speed_bin': speed_bin,
    'angle': angle_magnitude
}).dropna()

# --- Optional: Equalize group sizes via subsampling (to same count per bin) ---
min_count = df['speed_bin'].value_counts().min()
df_equal = df.groupby('speed_bin').sample(n=min_count, random_state=42)

# --- Plot (use seaborn for clarity) ---
plt.figure(figsize=(10, 5))
sns.violinplot(data=df_equal, x='speed_bin', y='angle', inner='quartile', palette='plasma')
plt.xlabel("Speed Bin (nm/min)")
plt.ylabel("|Turning Angle| (degrees)")
plt.title("Turning Angle Distributions by Speed Bin (Equal Sample Size)")
plt.grid(True)
plt.tight_layout()
plt.show()

"""This will give actual turning angles of the motor using 3 trajectory points per calculation"""

import numpy as np
import matplotlib.pyplot as plt

def calculate_relative_turning_angle(trajectory_data):
    """
    Calculates the turning angle between vectors formed by 3 consecutive points.
    Returns angles in degrees, signed from -180 to 180.
    """
    turning_angles = []

    for i in range(len(trajectory_data) - 2):
        x0, y0 = trajectory_data[i]
        x1, y1 = trajectory_data[i + 1]
        x2, y2 = trajectory_data[i + 2]

        # Create direction vectors
        v1 = np.array([x1 - x0, y1 - y0])
        v2 = np.array([x2 - x1, y2 - y1])

        # Normalize to unit vectors
        v1_norm = v1 / np.linalg.norm(v1)
        v2_norm = v2 / np.linalg.norm(v2)

        # Calculate signed turning angle
        dot = np.clip(np.dot(v1_norm, v2_norm), -1.0, 1.0)
        cross = np.cross(v1_norm, v2_norm)
        angle_rad = np.arctan2(cross, dot)
        angle_deg = np.degrees(angle_rad)  # signed: -180 to +180

        turning_angles.append(angle_deg)

    return turning_angles

# ---- Example usage ----
trajectory_data = zero_arr[:, 2:4]

# Calculate turning angles
turning_angles_deg = calculate_relative_turning_angle(trajectory_data)

# Convert to radians for polar plot
turning_angles_rad = np.radians(turning_angles_deg)

# --- Histogram plot ---
plt.figure(figsize=(8, 5))
plt.hist(turning_angles_deg, bins=36, color='steelblue', edgecolor='black')
plt.title("Histogram of Relative Turning Angles")
plt.xlabel("Turning Angle (degrees)")
plt.ylabel("Frequency")
plt.grid(True)
plt.tight_layout()
plt.show()

# --- Polar histogram ---
plt.figure(figsize=(6, 6))
ax = plt.subplot(111, polar=True)
ax.hist(turning_angles_rad, bins=36, color='mediumseagreen', edgecolor='black')
ax.set_theta_zero_location("N")
ax.set_theta_direction(-1)
ax.set_title("Polar Plot of Relative Turning Angles", va='bottom')
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def plot_polar_turning_angles(turning_angles_deg, num_bins=36):
    """
    Plots a full circular, clearly labeled polar histogram
    from precomputed turning angles (in degrees).
    """
    turning_angles_rad = np.radians(turning_angles_deg)

    fig = plt.figure(figsize=(7, 7))
    ax = plt.subplot(111, polar=True)
    n, bins, patches = ax.hist(
        turning_angles_rad,
        bins=num_bins,
        color='mediumseagreen',
        edgecolor='black',
        alpha=0.8
    )

    # Orientation and angular labels
    ax.set_theta_zero_location("S")   # 0° at top
    ax.set_theta_direction(-1)        # clockwise positive
    ax.set_thetagrids(
        np.arange(0, 360, 45),
        labels=[f"{ang}°" for ang in np.arange(0, 360, 45)],
        fontsize=12
    )

    # Style updates
    ax.set_title(
        "Polar Distribution of Relative Turning Angles\n(0° = Forward Direction)",
        fontsize=16,
        va='bottom',
        pad=35  # increases space between title and top label
    )
    ax.grid(True, linestyle='--', color='black', alpha=0.7)
    ax.set_yticklabels([])  # remove radial labels (1000, 2000, etc.)

    plt.tight_layout()
    plt.show()

# Example usage:
plot_polar_turning_angles(turning_angles_deg)

import numpy as np
import matplotlib.pyplot as plt

def calculate_relative_turning_angle(trajectory_data):
    turning_angles = []
    for i in range(len(trajectory_data) - 2):
        x0, y0 = trajectory_data[i]
        x1, y1 = trajectory_data[i + 1]
        x2, y2 = trajectory_data[i + 2]

        v1 = np.array([x1 - x0, y1 - y0])
        v2 = np.array([x2 - x1, y2 - y1])

        v1_norm = v1 / np.linalg.norm(v1)
        v2_norm = v2 / np.linalg.norm(v2)

        dot = np.clip(np.dot(v1_norm, v2_norm), -1.0, 1.0)
        cross = np.cross(v1_norm, v2_norm)
        angle_rad = np.arctan2(cross, dot)
        angle_deg = np.degrees(angle_rad)
        turning_angles.append(angle_deg)
    return turning_angles

# Group by Bead ID and calculate turning angles
bead_ids = np.unique(zero_arr[:, 0])
bead_turning_dict = {}

for bead_id in bead_ids:
    traj = zero_arr[zero_arr[:, 0] == bead_id][:, 2:4]  # extract x, y
    if len(traj) >= 3:
        angles = calculate_relative_turning_angle(traj)
        bead_turning_dict[int(bead_id)] = angles

# Plot histograms for first N beads (or all if small set)
N = 12  # adjust based on how many you want to view at once
selected_beads = list(bead_turning_dict.keys())[:N]

fig, axs = plt.subplots(3, 4, figsize=(18, 10))  # adjust grid size to match N
axs = axs.flatten()

for i, bead_id in enumerate(selected_beads):
    axs[i].hist(bead_turning_dict[bead_id], bins=36, color='steelblue', edgecolor='black')
    axs[i].set_title(f"Bead {bead_id}")
    axs[i].set_xlim([-180, 180])
    axs[i].set_xlabel("Angle (°)")
    axs[i].set_ylabel("Frequency")

plt.tight_layout()
plt.show()

"""# **X-Y Plot Thresholding & Histogram development**"""

#Re-assign zero_arr bead id's to consistent list ranging from 1 to whatever the last bead is

def reassign_bead_ids(zero_arr):
    # Get the unique bead IDs from the first column
    unique_beads = np.unique(zero_arr[:, 0])

    # Create a dictionary mapping old bead IDs to new sequential IDs
    bead_id_mapping = {old_id: new_id for new_id, old_id in enumerate(unique_beads, start=1)}

    # Create a copy of zero_arr with the new bead IDs
    new_zero_arr = zero_arr.copy()

    # Replace the old bead IDs with the new ones using the mapping
    for old_id, new_id in bead_id_mapping.items():
        new_zero_arr[new_zero_arr[:, 0] == old_id, 0] = new_id

    return new_zero_arr, bead_id_mapping

# Example usage
new_zero_arr, bead_id_mapping = reassign_bead_ids(zero_arr)

# Print the first few rows of the new_zero_arr
print(new_zero_arr[:10])

# Print the bead_id_mapping dictionary
print(bead_id_mapping)

import numpy as np

def calculate_velocity_for_bead(bead_data, time_interval_minutes):
    velocities = []
    for i in range(1, len(bead_data)):
        x1, y1 = bead_data[i - 1, 2], bead_data[i - 1, 3]
        x2, y2 = bead_data[i, 2], bead_data[i, 3]
        delta_x = x2 - x1
        delta_y = y2 - y1
        displacement = np.sqrt(delta_x**2 + delta_y**2)
        velocity = displacement / time_interval_minutes
        velocities.append(velocity)
    return velocities

def calculate_percentile_velocities(new_zero_arr, time_interval_seconds=5, percentiles=[10, 25, 50, 75, 90]):
    time_interval_minutes = time_interval_seconds / 60
    all_velocities = []

    # Loop through all beads and collect their velocities
    for bead_id in np.unique(new_zero_arr[:, 0]):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)
        all_velocities.extend(velocities)

    # Calculate the requested percentiles
    percentile_values = np.percentile(all_velocities, percentiles)

    # Print the percentile velocities
    for p, value in zip(percentiles, percentile_values):
        print(f"{p}th percentile velocity: {value} micron/min")

    return percentile_values

def get_threshold_velocity(percentile_values, percentile_index=10):
    # Get the velocity at the desired percentile (default is the 10th percentile)
    threshold_velocity = percentile_values[percentile_index]
    #print(f"Threshold velocity ({percentile_index}th percentile): {threshold_velocity} micron/min")
    return threshold_velocity

# Example usage: Calculate percentile velocities and get the 10th percentile as the threshold
percentiles = [1, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
percentile_values = calculate_percentile_velocities(new_zero_arr, percentiles=percentiles)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors

def calculate_velocity_for_all_beads(new_zero_arr, time_interval_minutes):
    all_velocities = []
    # Iterate through all unique bead IDs
    unique_beads = np.unique(new_zero_arr[:, 0])  # Assuming bead IDs are in the first column
    for bead_id in unique_beads:
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)
        all_velocities.extend(velocities)  # Add velocities to the list
    return all_velocities

def plot_velocity_distribution(new_zero_arr, time_interval_seconds=5, conversion_factor=0.55):
    time_interval_minutes = time_interval_seconds / 60
    # Calculate velocities for all beads
    all_velocities = calculate_velocity_for_all_beads(new_zero_arr, time_interval_minutes)

    # Create the histogram as a Probability Density Function
    fig, ax = plt.subplots(figsize=(10, 6))
    n, bins, patches = ax.hist(all_velocities, bins=100, density=True, edgecolor='black', alpha=1)

    # Calculate the midpoints of each bin for colormap application
    bin_centers = 0.5 * (bins[1:] + bins[:-1])

    # Apply the colormap using gist_rainbow, where the color represents the velocity value
    norm = colors.Normalize(vmin=min(all_velocities), vmax=max(all_velocities))
    cmap = plt.get_cmap('gist_rainbow')

    # Color the bars based on the velocity values (bin centers)
    for i in range(len(patches)):
        patches[i].set_facecolor(cmap(norm(bin_centers[i])))

    # Add a colorbar
    #cbar = plt.colorbar(plt.cm.ScalarMappable(cmap=cmap, norm=norm), ax=ax)
    #cbar.set_label('Velocity (micron/min)', fontsize=18)

    # Set plot labels and title
    ax.set_title('Velocity Distribution of Beads (PDF)', fontsize=22, color='Black')
    ax.set_xlabel('Velocity (micron/min)', fontsize=20, color='Black')
    ax.set_ylabel('Probability Density', fontsize=20, color='Black')

    ax.set_xlim([0, 6])

    # Customize tick parameters and set background color to black
    ax.tick_params(axis='both', which='major', labelsize=16, labelcolor='Black')
    fig.patch.set_facecolor('white')
    ax.set_facecolor('black')

    # Set gridlines with 0.75 alpha value and customize grid color, move gridlines behind the plot
    ax.grid(False, linestyle='--', alpha=0, color='white', zorder=0)

    # Show layout and plot
    plt.tight_layout()
    plt.show()

# Example usage: Plot the velocity distribution
plot_velocity_distribution(new_zero_arr)

# Assuming new_zero_arr has 4 columns: bead_id, frame#, x, y
column_names = ['BeadID', 'Frame', 'X', 'Y']

# Convert new_zero_arr to a pandas DataFrame
new_zero_df = pd.DataFrame(new_zero_arr, columns=column_names)

# Display the first few rows of the DataFrame
print(new_zero_df.head())

# export csv file
# choose file name
file_name="output_New_Zero_Array_W3.csv"

output = new_zero_df

output.to_csv(file_name)
files.download(file_name) #remove the comment symbol to download

import pandas as pd

def create_velocity_dataframe(new_zero_arr, bead_velocities_array, num_frames):
    """
    Create a pandas DataFrame containing velocities for all beads.

    Parameters:
        new_zero_arr (numpy.ndarray): Original data array containing bead information.
        bead_velocities_array (numpy.ndarray): Array of calculated velocities for each bead.
        num_frames (int): Number of frames in the dataset.

    Returns:
        pd.DataFrame: DataFrame containing bead velocities with BeadID and Frame#.
    """
    # Initialize an empty list to collect data
    velocity_data = []

    # Unique BeadIDs
    unique_beads = np.unique(new_zero_arr[:, 0])

    # Iterate through each bead
    for bead_index, bead_id in enumerate(unique_beads):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = bead_velocities_array[bead_index, :]  # Velocities for this bead

        # Append velocity data along with BeadID and Frame#
        for frame, velocity in enumerate(velocities, start=1):  # Frame numbering starts from 1
            if not np.isnan(velocity):  # Ignore NaN values
                velocity_data.append([bead_id, frame, velocity])

    # Create a pandas DataFrame from the collected data
    velocity_df = pd.DataFrame(velocity_data, columns=["BeadID", "Frame#", "Velocity (μm/min)"])

    return velocity_df


# Create the velocity DataFrame
velocity_df = create_velocity_dataframe(new_zero_arr, bead_velocities_array, num_frames)

# Display the first few rows of the DataFrame
print(velocity_df.head())

# Save to a CSV file for future use
velocity_df.to_csv("velocity_data.csv", index=False)
print("Velocity DataFrame saved as 'velocity_data.csv'.")

# export csv file
# choose file name
file_name="velocity_data.csv"
files.download(file_name) #remove the comment symbol to download

def set_threshold_velocity(new_zero_arr, time_interval_seconds=5):
    time_interval_minutes = time_interval_seconds / 60
    all_velocities = []

    # Loop through all beads and collect their velocities
    for bead_id in np.unique(new_zero_arr[:, 0]):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)
        all_velocities.extend(velocities)

    # Calculate the mean and standard deviation
    mean_velocity = np.mean(all_velocities)
    median_velocity = np.median(all_velocities)
    std_velocity = np.std(all_velocities)

    # Set threshold velocity as mean
    threshold_velocity = median_velocity

    print(f"Mean velocity: {mean_velocity} micron/min")
    print(f"Median velocity: {median_velocity} micron/min")
    print(f"Standard deviation of velocities: {std_velocity} micron/min")

    return threshold_velocity

# Example usage: Set the threshold velocity
threshold_velocity = set_threshold_velocity(new_zero_arr)
print(f'Final threshold velocity is {threshold_velocity}')

"""# **Instantaneous Speed Medusa Plot**"""

import numpy as np

def calculate_velocity_for_bead(bead_data, time_interval_minutes):
    velocities = []
    for i in range(1, len(bead_data)):
        x1, y1 = bead_data[i - 1, 2], bead_data[i - 1, 3]
        x2, y2 = bead_data[i, 2], bead_data[i, 3]
        delta_x = x2 - x1
        delta_y = y2 - y1
        displacement = np.sqrt(delta_x**2 + delta_y**2)
        velocity = displacement / time_interval_minutes
        velocities.append(velocity)
    return velocities

def calculate_velocities_for_all_beads(new_zero_arr, num_frames, time_interval_seconds=5):
    time_interval_minutes = time_interval_seconds / 60
    unique_beads = np.unique(new_zero_arr[:, 0])
    num_beads = len(unique_beads)
    bead_velocities = np.full((num_beads, num_frames - 1), np.nan)  # Create a padded array for velocities

    # Iterate through all unique bead IDs
    for bead_index, bead_id in enumerate(unique_beads):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)

        # Fill the velocity array for the bead
        bead_velocities[bead_index, :len(velocities)] = velocities

    # Print min and max velocities for all beads
    valid_velocities = bead_velocities[~np.isnan(bead_velocities)]
    print(f"Min velocity: {np.min(valid_velocities):.2f} μm/min")
    print(f"Max velocity: {np.max(valid_velocities):.2f} μm/min")

    return bead_velocities

# Assuming new_zero_arr is defined and has 361 frames per bead
num_frames = 361  # Number of frames per bead
time_interval_seconds = 5  # Time interval between frames in seconds

# Calculate velocities
bead_velocities_array = calculate_velocities_for_all_beads(new_zero_arr, num_frames, time_interval_seconds)

# bead_velocities_array is a 2D array where each row corresponds to the velocities of a bead across all frames.

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

def plot_beads_with_velocity(new_zero_arr, bead_velocities_array, num_frames):
    # Setup for plot
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.set_facecolor("black")  # Set plot background to black
    plt.axis([-6, 6, -6, 6])

    # Normalize velocities for colormap
    valid_velocities = bead_velocities_array[~np.isnan(bead_velocities_array)]
    norm = plt.Normalize(valid_velocities.min(), vmax=6)#valid_velocities.max())

    # Iterate through all beads to plot trajectories
    unique_beads = np.unique(new_zero_arr[:, 0])
    time_interval_minutes = 5 / 60  # 5 seconds in minutes

    for bead_index, bead_id in enumerate(unique_beads):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]

        if bead_data.shape[0] < num_frames:
            continue  # Skip beads with incomplete data

        x = bead_data[:, 2]
        y = bead_data[:, 3]
        velocities = bead_velocities_array[bead_index, :]  # Extract velocities for the bead

        # Skip beads with incomplete velocities
        if np.isnan(velocities).any():
            continue

        # Create segments for the trajectory
        points = np.array([x, y]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)

        # Add trajectory to plot with velocity-based color mapping
        trajectory = LineCollection(segments, cmap="gist_rainbow", norm=norm, linewidth=1)
        trajectory.set_array(velocities)
        ax.add_collection(trajectory)

    # Add colorbar for velocity
    cbar = fig.colorbar(trajectory, ax=ax)
    cbar.set_label("Speed (μm/min)", fontsize=20)
    cbar.ax.tick_params(labelsize=16)

    # Set custom ticks based on the normalization range
    tick_range = np.linspace(norm.vmin, norm.vmax, num=6)  # Generate 6 evenly spaced ticks
    cbar.set_ticks(tick_range)
    # Format the tick labels to two decimal places
    cbar.set_ticklabels([f"{tick:.0f}" for tick in tick_range])  # Use format specifier for 2 decimal places

    # Plot settings
    plt.xlabel("x position (μm)", fontsize=20)
    plt.ylabel("y position (μm)", fontsize=20)
    plt.setp(ax.get_xticklabels(), fontsize=16)
    plt.setp(ax.get_yticklabels(), fontsize=16)
    plt.grid(visible=True, linestyle='--', linewidth=0.5, color='gray')
   # plt.title("Trajectories with Velocity Colormap", fontsize=22)
    plt.show()

# Call the plotting function
plot_beads_with_velocity(new_zero_arr, bead_velocities_array, num_frames)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

def plot_bead_with_velocity(new_zero_arr, bead_velocities_array, num_frames, selected_bead_id):
    # Setup for plot
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.set_facecolor("black")  # Set plot background to black
    plt.axis([-5, 5, -5, 5])

    # Normalize velocities for colormap
    valid_velocities = bead_velocities_array[~np.isnan(bead_velocities_array)]
    norm = plt.Normalize(valid_velocities.min(), valid_velocities.max())

    # Select data for the specific bead
    bead_data = new_zero_arr[new_zero_arr[:, 0] == selected_bead_id]

    if bead_data.shape[0] < num_frames:
        print(f"BeadID {selected_bead_id} has incomplete data.")
        return  # Skip if bead data is incomplete

    x = bead_data[:, 2]
    y = bead_data[:, 3]
    bead_index = int(np.where(np.unique(new_zero_arr[:, 0]) == selected_bead_id)[0])  # Get bead index
    velocities = bead_velocities_array[bead_index, :]  # Extract velocities for the bead

    # Skip if velocities are incomplete
    if np.isnan(velocities).any():
        print(f"BeadID {selected_bead_id} has incomplete velocity data.")
        return

    # Create segments for the trajectory
    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)

    # Add trajectory to plot with velocity-based color mapping
    trajectory = LineCollection(segments, cmap="gist_rainbow", norm=norm, linewidth=2)
    trajectory.set_array(velocities)
    ax.add_collection(trajectory)

    # Add colorbar for velocity
    cbar = fig.colorbar(trajectory, ax=ax)
    cbar.set_label("Speed (μm/min)", fontsize=20)
    cbar.ax.tick_params(labelsize=16)

    # Set custom ticks based on the normalization range
    tick_range = np.linspace(norm.vmin, norm.vmax, num=6)  # Generate 6 evenly spaced ticks
    cbar.set_ticks(tick_range)
    cbar.set_ticklabels([f"{tick:.0f}" for tick in tick_range])  # Format tick labels

    # Plot settings
    plt.xlabel("x position (μm)", fontsize=20)
    plt.ylabel("y position (μm)", fontsize=20)
    plt.setp(ax.get_xticklabels(), fontsize=16)
    plt.setp(ax.get_yticklabels(), fontsize=16)
    plt.grid(visible=True, linestyle='--', linewidth=0.5, color='gray')
    #plt.title(f"Trajectory of BeadID {selected_bead_id} with Velocity Colormap", fontsize=22)
    plt.show()

# Specify the BeadID you want to plot
selected_bead_id = 5  # Replace with the desired BeadID

# Call the updated plotting function
plot_bead_with_velocity(new_zero_arr, bead_velocities_array, num_frames, selected_bead_id)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

def plot_bead_with_velocity(new_zero_arr, bead_velocities_array, num_frames, selected_bead_id):
    # Setup for plot
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.set_facecolor("black")  # Set plot background to black
    plt.axis([-5, 5, -5, 5])

    # Select data for the specific bead
    bead_data = new_zero_arr[new_zero_arr[:, 0] == selected_bead_id]
    if bead_data.shape[0] < num_frames:
        print(f"BeadID {selected_bead_id} has incomplete data.")
        return

    x = bead_data[:, 2]
    y = bead_data[:, 3]
    bead_index = int(np.where(np.unique(new_zero_arr[:, 0]) == selected_bead_id)[0])
    velocities = bead_velocities_array[bead_index, :]

    if np.isnan(velocities).any():
        print(f"BeadID {selected_bead_id} has incomplete velocity data.")
        return

    # Normalize based on this bead's velocity range only
    valid_velocities = velocities[~np.isnan(velocities)]
    norm = plt.Normalize(valid_velocities.min(), valid_velocities.max())

    # Create segments
    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)

    # Create colored trajectory
    trajectory = LineCollection(segments, cmap="gist_rainbow", norm=norm, linewidth=2)
    trajectory.set_array(velocities)
    ax.add_collection(trajectory)

    # Add colorbar for this bead only
    cbar = fig.colorbar(trajectory, ax=ax)
    cbar.set_label("Speed (μm/min)", fontsize=20)
    cbar.ax.tick_params(labelsize=16)

    # Tick marks customized to this bead's velocity range
    tick_range = np.linspace(norm.vmin, norm.vmax, num=6)
    cbar.set_ticks(tick_range)
    cbar.set_ticklabels([f"{tick:.0f}" for tick in tick_range])

    # Axis and labels
    plt.xlabel("x position (μm)", fontsize=20)
    plt.ylabel("y position (μm)", fontsize=20)
    plt.setp(ax.get_xticklabels(), fontsize=16)
    plt.setp(ax.get_yticklabels(), fontsize=16)
    plt.grid(visible=True, linestyle='--', linewidth=0.5, color='gray')
    # plt.title(f"Trajectory of BeadID {selected_bead_id}", fontsize=22)
    plt.show()

# Example usage
selected_bead_id = 24  # Update this as needed
plot_bead_with_velocity(new_zero_arr, bead_velocities_array, num_frames, selected_bead_id)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

def plot_bead_instantaneous_speed(new_zero_arr, bead_velocities_array, num_frames, selected_bead_id, time_interval_seconds=5):
    # Convert to minutes
    time_interval_minutes = time_interval_seconds / 60

    # Select data for the specific bead
    bead_data = new_zero_arr[new_zero_arr[:, 0] == selected_bead_id]
    if bead_data.shape[0] < num_frames:
        print(f"BeadID {selected_bead_id} has incomplete data.")
        return

    bead_index = int(np.where(np.unique(new_zero_arr[:, 0]) == selected_bead_id)[0])
    velocities = bead_velocities_array[bead_index, :]

    if np.isnan(velocities).any():
        print(f"BeadID {selected_bead_id} has incomplete velocity data.")
        return

    # Time points: one fewer than num_frames
    time_points = np.arange(1, len(velocities) + 1) * time_interval_minutes

    # Normalize based on this bead's velocity range only
    valid_velocities = velocities[~np.isnan(velocities)]
    norm = plt.Normalize(valid_velocities.min(), valid_velocities.max())

    # Create segments for LineCollection
    points = np.array([time_points, velocities]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)

    # Setup for plot
    fig, ax = plt.subplots(figsize=(10, 8))
    line = LineCollection(segments, cmap="gist_rainbow", norm=norm, linewidth=2)
    line.set_array(velocities)
    ax.add_collection(line)

    # Set axes limits and labels
    ax.set_xlim(time_points.min(), time_points.max())
    ax.set_ylim(valid_velocities.min() * 0.95, valid_velocities.max() * 1.05)
    ax.set_xlabel("Time (minutes)", fontsize=20)
    ax.set_ylabel("Instantaneous Speed (μm/min)", fontsize=20)
    ax.set_facecolor("white")
    ax.tick_params(labelsize=16)
    ax.grid(True, linestyle='--', linewidth=0.5, color='gray')

    # Add colorbar
    cbar = fig.colorbar(line, ax=ax)
    cbar.set_label("Speed (μm/min)", fontsize=20)
    cbar.ax.tick_params(labelsize=16)

    # Custom tick marks
    tick_range = np.linspace(norm.vmin, norm.vmax, num=6)
    cbar.set_ticks(tick_range)
    cbar.set_ticklabels([f"{tick:.0f}" for tick in tick_range])

    # Optional title
    # ax.set_title(f"Instantaneous Speed of Bead {selected_bead_id}", fontsize=22)

    plt.tight_layout()
    plt.show()

selected_bead_id = 2
plot_bead_instantaneous_speed(new_zero_arr, bead_velocities_array, num_frames, selected_bead_id)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

def plot_first_10_beads_instantaneous_speed(new_zero_arr, bead_velocities_array, num_frames, time_interval_seconds=5):
    time_interval_minutes = time_interval_seconds / 60

    # Select the first 10 unique bead IDs
    all_beads = np.unique(new_zero_arr[:, 0])
    bead_ids = all_beads[:10]

    # Set up the subplot grid
    fig, axes = plt.subplots(10, 1, figsize=(10, 40), sharex=True)

    for idx, selected_bead_id in enumerate(bead_ids):
        ax = axes[idx]

        # Extract data for the bead
        bead_data = new_zero_arr[new_zero_arr[:, 0] == selected_bead_id]
        if bead_data.shape[0] < num_frames:
            print(f"BeadID {selected_bead_id} has incomplete data.")
            continue

        bead_index = int(np.where(all_beads == selected_bead_id)[0])
        velocities = bead_velocities_array[bead_index, :]

        if np.isnan(velocities).any():
            print(f"BeadID {selected_bead_id} has incomplete velocity data.")
            continue

        time_points = np.arange(1, len(velocities) + 1) * time_interval_minutes
        valid_velocities = velocities[~np.isnan(velocities)]

        norm = plt.Normalize(vmin=valid_velocities.min(), vmax=valid_velocities.max())
        points = np.array([time_points, velocities]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)

        line = LineCollection(segments, cmap="gist_rainbow", norm=norm, linewidth=2)
        line.set_array(velocities)
        ax.add_collection(line)

        ax.set_xlim(time_points.min(), time_points.max())
        ax.set_ylim(valid_velocities.min() * 0.95, valid_velocities.max() * 1.05)
        ax.set_ylabel("Speed (μm/min)", fontsize=16)
        ax.set_facecolor("white")
        ax.tick_params(labelsize=14)
        ax.grid(True, linestyle='--', linewidth=0.5, color='gray')
        ax.set_title(f"Bead {int(selected_bead_id)}", fontsize=18)

        # Add colorbar
        cbar = fig.colorbar(line, ax=ax)
        cbar.set_label("Speed (μm/min)", fontsize=14)
        cbar.ax.tick_params(labelsize=12)
        tick_range = np.linspace(norm.vmin, norm.vmax, num=6)
        cbar.set_ticks(tick_range)
        cbar.set_ticklabels([f"{tick:.0f}" for tick in tick_range])

    axes[-1].set_xlabel("Time (minutes)", fontsize=16)
    plt.tight_layout()
    plt.show()

plot_first_10_beads_instantaneous_speed(new_zero_arr, bead_velocities_array, num_frames)

"""# **X-Y Coordinate Plot for Single motor**"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable
from matplotlib.collections import LineCollection

def calculate_velocity_for_bead(bead_data, time_interval_minutes):
    velocities = []
    for i in range(1, len(bead_data)):
        x1, y1 = bead_data[i - 1, 2], bead_data[i - 1, 3]
        x2, y2 = bead_data[i, 2], bead_data[i, 3]
        delta_x = x2 - x1
        delta_y = y2 - y1
        displacement = np.sqrt(delta_x**2 + delta_y**2)
        velocity = displacement / time_interval_minutes
        velocities.append(velocity)
    return velocities

def identify_motion_states(velocities, threshold):
    motion_states = ['Moving' if vel >= threshold else 'Low Motion' for vel in velocities]
    return motion_states

def calculate_velocities_for_all_beads(new_zero_arr, time_interval_minutes):
    all_velocities = {}

    # Loop through all unique bead IDs in the data
    for bead_id in np.unique(new_zero_arr[:, 0]):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)
        all_velocities[bead_id] = velocities

    return all_velocities

def analyze_bead_motion(new_zero_arr, bead_id, time_interval_seconds=5, conversion_factor=0.55):
    time_interval_minutes = time_interval_seconds / 60
    bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
    frame_numbers = bead_data[:, 1]
    time_values = frame_numbers * time_interval_minutes

    velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)
    motion_states = identify_motion_states(velocities, threshold_velocity)

    # Convert positions to microns
    bead_data[:, 2] *= conversion_factor  # X positions in microns
    bead_data[:, 3] *= conversion_factor  # Y positions in microns

    # Calculate velocities for all beads to determine a consistent threshold
    all_velocities = calculate_velocities_for_all_beads(new_zero_arr, time_interval_minutes)

    # Get the maximum velocity across all beads for the colorbar range
    max_velocity = max(max(velocities) for velocities in all_velocities.values())

    # Create the figure with 2 horizontally stacked subplots (1 row, 2 columns)
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(30, 8))  # Horizontally stacked (1 row, 2 columns)

    # Set black background
    fig.patch.set_facecolor('white')
    ax1.set_facecolor('black')
    ax2.set_facecolor('black')

    # Create line segments for X trajectory
    segments_x = []
    for i in range(1, len(bead_data)):
        segments_x.append([[time_values[i - 1], bead_data[i - 1, 2]], [time_values[i], bead_data[i, 2]]])

    # Create line segments for Y trajectory
    segments_y = []
    for i in range(1, len(bead_data)):
        segments_y.append([[time_values[i - 1], bead_data[i - 1, 3]], [time_values[i], bead_data[i, 3]]])


    # Create LineCollection for X trajectory with color based on velocity using gist_rainbow colormap
    lc_x = LineCollection(segments_x, cmap='gist_rainbow', array=velocities, linewidth=4)
    lc_x.set_array(np.array(velocities))  # Set the velocity values
    lc_x.set_clim(0, max_velocity)  # Set consistent color limits across all plots
    ax1.add_collection(lc_x)
    ax1.set_ylabel('X Position (microns)', fontsize=20, color='black')  # Set custom font size for Y axis label
    #ax1.set_title(f'X Trajectory of Motor {int(bead_id)}', fontsize=22, color='black')  # Set custom font size for title
    ax1.set_xlim([time_values[0], time_values[-1]])
    ax1.set_ylim([min(bead_data[:, 2]), max(bead_data[:, 2])])
    ax1.autoscale()
    ax1.grid(True, color='white', alpha=0.5)

    # Create LineCollection for Y trajectory with color based on velocity using gist_rainbow colormap
    lc_y = LineCollection(segments_y, cmap='gist_rainbow', array=velocities, linewidth=4)
    lc_y.set_array(np.array(velocities))  # Set the velocity values
    lc_y.set_clim(0, max_velocity)  # Set consistent color limits across all plots
    ax2.add_collection(lc_y)
    ax2.set_xlabel('Time (minutes)', fontsize=20, color='black')  # Set custom font size for X axis label
    ax2.set_ylabel('Y Position (microns)', fontsize=20, color='black')  # Set custom font size for Y axis label
    #ax2.set_title(f'Y Trajectory of Motor {int(bead_id)}', fontsize=22, color='black')  # Set custom font size for title
    ax2.set_xlim([time_values[0], time_values[-1]])
    ax2.set_ylim([min(bead_data[:, 3]), max(bead_data[:, 3])])
    ax2.autoscale()
    ax2.grid(True, color='white', alpha=0.5)

    # Set custom font size for tick labels
    ax1.tick_params(axis='both', which='major', labelsize=16, colors='black')  # Custom font size for X and Y ticks on ax1
    ax2.tick_params(axis='both', which='major', labelsize=16, colors='black')  # Custom font size for X and Y ticks on ax2

    # Create a divider for the colorbar to the right of the second plot (ax2)
    divider = make_axes_locatable(ax2)  # Using ax2 to create space for colorbar
    cax = divider.append_axes("right", size="5%", pad=0.1)  # Adjust pad for distance between plots and colorbar

    # Add colorbar spanning the height of both plots
    cbar = fig.colorbar(lc_y, cax=cax)
    cbar.set_label('Velocity (micron/min)', fontsize=18, color='black')  # Custom font size for colorbar label
    cbar.ax.tick_params(labelsize=16, colors='black')  # Set font size for colorbar ticks and make them white

    # Adjust the spacing between the subplots using plt.subplots_adjust
    plt.subplots_adjust(wspace=0.2)  # Adjust the space between the plots

    # Show the plot with the adjusted layout
    plt.tight_layout()  # Adjust subplots to ensure proper layout
    plt.show()

    # Print motion states for each frame
    print(f"Motion states for Motor {int(bead_id)}:", motion_states)

# Example usage: Analyze motion for bead with ID 1
bead_id = 5  # Replace with the bead ID you want to analyze #299 is mad fast
analyze_bead_motion(new_zero_arr, bead_id)

"""# **X-Y Coordinate Plot for All Motors**"""

import numpy as np

def calculate_velocity_for_bead(bead_data, time_interval_minutes):
    velocities = []
    for i in range(1, len(bead_data)):
        x1, y1 = bead_data[i - 1, 2], bead_data[i - 1, 3]
        x2, y2 = bead_data[i, 2], bead_data[i, 3]
        delta_x = x2 - x1
        delta_y = y2 - y1
        displacement = np.sqrt(delta_x**2 + delta_y**2)
        velocity = displacement / time_interval_minutes
        velocities.append(velocity)
    return velocities

def calculate_velocities_for_all_beads(new_zero_arr, num_frames, time_interval_seconds=5):
    time_interval_minutes = time_interval_seconds / 60
    unique_beads = np.unique(new_zero_arr[:, 0])
    num_beads = len(unique_beads)
    bead_velocities = np.full((num_beads, num_frames - 1), np.nan)  # Create a padded array for velocities

    # Iterate through all unique bead IDs
    for bead_index, bead_id in enumerate(unique_beads):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)

        # Fill the velocity array for the bead
        bead_velocities[bead_index, :len(velocities)] = velocities

    # Print min and max velocities for all beads
    valid_velocities = bead_velocities[~np.isnan(bead_velocities)]
    print(f"Min velocity: {np.min(valid_velocities):.2f} μm/min")
    print(f"Max velocity: {np.max(valid_velocities):.2f} μm/min")

    return bead_velocities

# Assuming new_zero_arr is defined and has 361 frames per bead
num_frames = 361  # Number of frames per bead
time_interval_seconds = 5  # Time interval between frames in seconds

# Calculate velocities
bead_velocities_array = calculate_velocities_for_all_beads(new_zero_arr, num_frames, time_interval_seconds)

# bead_velocities_array is a 2D array where each row corresponds to the velocities of a bead across all frames.

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from matplotlib import cm

# --- Velocity Calculation ---
def calculate_velocity_for_bead(bead_data, time_interval_minutes):
    velocities = []
    for i in range(1, len(bead_data)):
        x1, y1 = bead_data[i - 1, 2], bead_data[i - 1, 3]
        x2, y2 = bead_data[i, 2], bead_data[i, 3]
        delta_x = x2 - x1
        delta_y = y2 - y1
        displacement = np.sqrt(delta_x**2 + delta_y**2)
        velocity = displacement / time_interval_minutes
        velocities.append(velocity)
    return velocities

def calculate_velocities_for_all_beads(new_zero_arr, num_frames, time_interval_seconds=5):
    time_interval_minutes = time_interval_seconds / 60
    unique_beads = np.unique(new_zero_arr[:, 0])
    num_beads = len(unique_beads)
    bead_velocities = np.full((num_beads, num_frames - 1), np.nan)

    for bead_index, bead_id in enumerate(unique_beads):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = calculate_velocity_for_bead(bead_data, time_interval_minutes)
        bead_velocities[bead_index, :len(velocities)] = velocities

    valid_velocities = bead_velocities[~np.isnan(bead_velocities)]
    print(f"Min velocity: {np.min(valid_velocities):.2f} μm/min")
    print(f"Max velocity: {np.max(valid_velocities):.2f} μm/min")

    return bead_velocities

# --- Plotting Function ---
def plot_all_beads_movements(new_zero_arr, bead_velocities_array, time_interval_seconds=5):
    time_interval_minutes = time_interval_seconds / 60
    max_time_minutes = 30

    fig, axs = plt.subplots(1, 2, figsize=(40, 15), gridspec_kw={'width_ratios': [1, 1]})
    fig.patch.set_facecolor('white')
    for ax in axs:
        ax.set_facecolor('black')

    all_velocities = bead_velocities_array[~np.isnan(bead_velocities_array)]
    max_velocity = 7  # or use: np.max(all_velocities)
    norm = plt.Normalize(0, max_velocity)
    cmap = cm.gist_rainbow

    all_x_coords = []
    all_y_coords = []

    unique_beads = np.unique(new_zero_arr[:, 0])
    for bead_index, bead_id in enumerate(unique_beads):
        bead_data = new_zero_arr[new_zero_arr[:, 0] == bead_id]
        velocities = bead_velocities_array[bead_index, :len(bead_data) - 1]

        time_in_minutes = np.arange(len(bead_data)) * time_interval_minutes

        # Collect all x and y for axis scaling
        all_x_coords.extend(bead_data[:, 2])
        all_y_coords.extend(bead_data[:, 3])

        # X Trajectory
        x = bead_data[:, 2]
        points = np.array([time_in_minutes, x]).T
        segments = np.array([points[:-1], points[1:]]).transpose(1, 0, 2)
        lc_x = LineCollection(segments, cmap=cmap, norm=norm, alpha=1)
        lc_x.set_array(np.array(velocities))
        lc_x.set_linewidth(2)
        axs[0].add_collection(lc_x)

        # Y Trajectory
        y = bead_data[:, 3]
        points = np.array([time_in_minutes, y]).T
        segments = np.array([points[:-1], points[1:]]).transpose(1, 0, 2)
        lc_y = LineCollection(segments, cmap=cmap, norm=norm, alpha=1)
        lc_y.set_array(np.array(velocities))
        lc_y.set_linewidth(2)
        axs[1].add_collection(lc_y)

    # Axis limits
    padding = 0.05 * (max(all_x_coords) - min(all_x_coords))
    axs[0].set_ylim(min(all_x_coords) - padding, max(all_x_coords) + padding)
    padding = 0.05 * (max(all_y_coords) - min(all_y_coords))
    axs[1].set_ylim(min(all_y_coords) - padding, max(all_y_coords) + padding)

    axs[0].set_title("X Movements of All Beads", fontsize=42, color='black')
    axs[0].set_xlabel("Time (minutes)", fontsize=42, color='black')
    axs[0].set_ylabel("X Coordinate (micron)", fontsize=42, color='black')
    axs[0].grid(True, linestyle='--', alpha=1)
    axs[0].tick_params(axis='both', colors='black', labelsize=40)

    axs[1].set_title("Y Movements of All Beads", fontsize=42, color='black')
    axs[1].set_xlabel("Time (minutes)", fontsize=42, color='black')
    axs[1].set_ylabel("Y Coordinate (micron)", fontsize=42, color='black')
    axs[1].grid(True, linestyle='--', alpha=1)
    axs[1].tick_params(axis='both', colors='black', labelsize=40)

    for ax in axs:
        ax.set_xlim(0, max_time_minutes)
        ax.set_xticks(np.linspace(0, max_time_minutes, num=7))

    y_ticks = np.linspace(min(all_y_coords), max(all_y_coords), num=6)
    axs[1].set_yticks(y_ticks)
    axs[1].set_yticklabels([f'{tick:.2f}' for tick in y_ticks])

    cbar = fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=axs, orientation='vertical', pad=0.5)
    cbar.set_label("Speed (micron/min)", fontsize=46, color='black')
    cbar.set_ticks(np.linspace(0, max_velocity, num=6))
    cbar.ax.yaxis.set_tick_params(color='black', size=30)
    cbar.ax.yaxis.set_ticklabels([f'{tick:.0f}' for tick in np.linspace(0, max_velocity, num=6)], color='black', fontsize=42)
    cbar.ax.set_position([1, 0.1, 0.2, 0.8])

    plt.tight_layout()
    plt.show()

# --- Run the Analysis ---
num_frames = 361
time_interval_seconds = 5

bead_velocities_array = calculate_velocities_for_all_beads(new_zero_arr, num_frames, time_interval_seconds)
plot_all_beads_movements(new_zero_arr, bead_velocities_array, time_interval_seconds)

"""# **Instantaneous Speed vs time**

"""

import numpy as np
import matplotlib.pyplot as plt

# Settings
time_interval_seconds = 5  # time per frame
time_interval_minutes = time_interval_seconds / 60  # convert to minutes

# Calculate instantaneous speed (nm/min)
def calculate_instantaneous_speed(x, y):
    x = np.asarray(x, dtype=float)
    y = np.asarray(y, dtype=float)
    dx = np.diff(x)
    dy = np.diff(y)
    displacement = np.sqrt(dx**2 + dy**2)
    speed = displacement / time_interval_minutes  # nm/min
    return speed

# Get all unique beads
unique_beads = np.unique(cut_array[:, 0])

# Time array for plotting (n-1 points due to np.diff)
time_points = np.arange(1, 361) * time_interval_minutes

# Store all speeds for ensemble stats
all_speeds = []

for bead_id in unique_beads:
    bead_data = cut_array[cut_array[:, 0] == bead_id]
    x = bead_data[:, 2]
    y = bead_data[:, 3]
    if len(x) > 1:
        speed = calculate_instantaneous_speed(x, y)
        all_speeds.append(speed)

# Convert to array
all_speeds = np.array(all_speeds)

# Calculate ensemble mean and standard deviation
ensemble_avg = np.mean(all_speeds, axis=0)
ensemble_std = np.std(all_speeds, axis=0)

# Plot ensemble average with error band
plt.figure(figsize=(10, 8))

plt.plot(time_points[:len(ensemble_avg)], ensemble_avg, color='black', linewidth=3, label='Ensemble Average')
plt.fill_between(time_points[:len(ensemble_avg)],
                 ensemble_avg - ensemble_std,
                 ensemble_avg + ensemble_std,
                 color='gray', alpha=0.3, label='± SD')

# Gridlines (clean dashed style)
plt.grid(True, which='both', linestyle='--', linewidth=1, alpha=0.5)

# Axis and style settings
plt.xlabel('Time (minutes)', fontsize=20)
plt.ylabel('Instantaneous Speed (nm/min)', fontsize=20)
plt.title('Ensemble Average Instantaneous Speed of ExoIII Motors', fontsize=22)
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)
plt.legend(fontsize=14)
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np

# Settings
time_interval_seconds = 5  # time per frame
time_interval_minutes = time_interval_seconds / 60  # convert to minutes

# Calculate instantaneous speed (nm/min)
def calculate_instantaneous_speed(x, y):
    x = np.asarray(x, dtype=float)
    y = np.asarray(y, dtype=float)
    dx = np.diff(x)
    dy = np.diff(y)
    displacement = np.sqrt(dx**2 + dy**2)
    speed = displacement / time_interval_minutes  # nm/min
    return speed

# Get all unique beads
unique_beads = np.unique(cut_array[:, 0])

# Time array for plotting (n-1 points due to np.diff)
time_points = np.arange(1, 361) * time_interval_minutes

# Initialize dataframe with time
export_df = pd.DataFrame({'Time_min': time_points[:360]})  # 360 points because diff

# Store all bead speeds
all_speeds = []

for bead_id in unique_beads:
    bead_data = cut_array[cut_array[:, 0] == bead_id]
    x = bead_data[:, 2]
    y = bead_data[:, 3]
    if len(x) > 1:
        speed = calculate_instantaneous_speed(x, y)
        all_speeds.append(speed)
        # Add to export DataFrame
        export_df[f'Bead_{int(bead_id)}'] = speed

# Calculate ensemble mean and SD across all beads at each time point
all_speeds = np.array(all_speeds)
ensemble_avg = np.mean(all_speeds, axis=0)
ensemble_std = np.std(all_speeds, axis=0)

# Add ensemble columns
export_df['Ensemble_Avg_Speed'] = ensemble_avg
export_df['Ensemble_SD_Speed'] = ensemble_std

# Export as single CSV
export_df.to_csv('Instantaneous_Speed_Matrix.csv', index=False)

# For Colab: provide download link
from google.colab import files
files.download('Instantaneous_Speed_Matrix.csv')

import numpy as np

time_interval_seconds = 5
time_interval_minutes = time_interval_seconds / 60

# Convert all displacements to microns and calculate speed
all_speeds = []

for bead_id in np.unique(cut_array[:, 0]):
    bead_data = cut_array[cut_array[:, 0] == bead_id]
    x = bead_data[:, 2] / 1000  # nm to µm
    y = bead_data[:, 3] / 1000
    dx = np.diff(x)
    dy = np.diff(y)
    displacement = np.sqrt(dx**2 + dy**2)
    speed = displacement / time_interval_minutes
    all_speeds.extend(speed)

all_speeds = np.array(all_speeds)
vmin = np.nanmin(all_speeds)
vmax = np.nanmax(all_speeds)

print(f"Velocity range: {vmin:.2f} to {vmax:.2f} µm/min")

import numpy as np  # Re-import to fix np.sqrt, np.diff, etc.

plot_motor_trajectory_and_speed(cut_array, bead_id=2)

"""# **Cummulative Net Displacement vs Time**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Ensure zero_arr is numeric
zero_arr = zero_arr.astype(float)

# Time interval between frames (in seconds → convert to minutes)
time_interval_seconds = 5
time_interval_minutes = time_interval_seconds / 60

# Initialize tracking dictionaries
initial_positions = {}
displacement_lists = {}

# Process data
for element in range(len(zero_arr)):
    motor_id = zero_arr[element, 0]
    frame_number = int(zero_arr[element, 1])
    x = zero_arr[element, 2]
    y = zero_arr[element, 3]

    if frame_number == 0:
        initial_positions[motor_id] = (x, y)

    if motor_id in initial_positions:
        initial_x, initial_y = initial_positions[motor_id]
        delta = np.sqrt((x - initial_x) ** 2 + (y - initial_y) ** 2)
        d = delta * 1000  # µm to nm

        if frame_number not in displacement_lists:
            displacement_lists[frame_number] = []
        displacement_lists[frame_number].append(d)

# Compute per-frame average and std deviation
sorted_frames = sorted(displacement_lists.keys())
average_displacement = []
std_deviation = []
time_values = []

for frame in sorted_frames:
    values = displacement_lists[frame]
    average_displacement.append(np.mean(values))
    std_deviation.append(np.std(values))
    time_values.append(frame * time_interval_minutes)

# Create final combined DataFrame
df = pd.DataFrame({
    'Time (minutes)': time_values,
    'Average Net Displacement (nm)': average_displacement,
    'Standard Deviation (nm)': std_deviation
})

# Show DataFrame (optional)
# display(df)

# Plot both on the same figure
plt.figure(figsize=(12, 8))
plt.plot(df['Time (minutes)'], df['Average Net Displacement (nm)'], label='Mean Net Displacement', color='b')
plt.fill_between(df['Time (minutes)'],
                 df['Average Net Displacement (nm)'] - df['Standard Deviation (nm)'],
                 df['Average Net Displacement (nm)'] + df['Standard Deviation (nm)'],
                 color='blue', alpha=0.2, label='±1 SD')

plt.xlabel('Time (minutes)', fontsize=16)
plt.ylabel('Displacement (nm)', fontsize=16)
plt.title('Cumulative Net Displacement of Beads Over Time', fontsize=18)
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

from google.colab import files

# Set your file name here
filename = "W6_net_displacement_with_std.csv"

# Save to CSV
df.to_csv(filename, index=False)

# Trigger download in Colab
files.download(filename)

"""# **Filter out <100nm Motors**"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# --- Parameters ---
displ_threshold_um = 0.1  # 0.1 µm = 100 nm

# --- Net displacement calculation ---
net_displ = []
total_motors = 0
filtered_out = 0

for bead_id in np.unique(zero_arr[:, 0]):
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    frames = bead_data[:, 1]

    # auto-detect first and last frame
    start = bead_data[frames == frames.min()]
    end = bead_data[frames == frames.max()]

    if start.size > 0 and end.size > 0:
        total_motors += 1
        initial_x, initial_y = start[0, 2], start[0, 3]
        final_x, final_y = end[0, 2], end[0, 3]
        net_d = np.sqrt((final_x - initial_x)**2 + (final_y - initial_y)**2)

        # filter directly in µm
        if net_d >= displ_threshold_um:
            net_displ.append(net_d)
        else:
            filtered_out += 1

# --- Print summary ---
print("----- Net Displacement Summary -----")
print(f"Total motors analyzed: {total_motors}")
print(f"Motors filtered out (<{displ_threshold_um} µm): {filtered_out}")
print(f"Motors retained for analysis: {len(net_displ)}")
if len(net_displ) > 0:
    mean = round(np.mean(net_displ), 3)
    print(f"Mean net displacement (retained) = {mean} μm")
else:
    mean = 0
    print("No motors passed the filter.")
print("-----------------------------------")

# --- Plot ---
fig, ax = plt.subplots(figsize=(9,8))
if len(net_displ) > 0:
    ax = sns.boxplot(y=net_displ, palette="GnBu", saturation=0.5, width=0.4)
    sns.swarmplot(y=net_displ, color=".25")
    ax.set_title(f'Mean net displacement = {mean} μm', fontsize=20)
else:
    ax.set_title("Mean net displacement = 0 μm", fontsize=20)

plt.ylabel("Net displacement (μm)", fontsize=20)
plt.setp(ax.get_yticklabels(), fontsize=16)
ax.autoscale()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# --- Alpha value calculation for filtered motors ---

# Parameters
num_frames = 361
use_frames = 72  # initial 20% of time
lagtime = range(1, num_frames)  # in frames
lagtime_s = np.linspace(5, num_frames * 5, num_frames - 1)  # in seconds

# --- Step 1: identify valid beads based on net displacement ---
displ_threshold_um = 0.1
valid_beads = []

for bead_id in np.unique(zero_arr[:, 0]):
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    frames = bead_data[:, 1]

    if len(bead_data) != num_frames:
        continue

    start = bead_data[frames == frames.min()]
    end = bead_data[frames == frames.max()]

    if start.size > 0 and end.size > 0:
        initial_x, initial_y = start[0, 2], start[0, 3]
        final_x, final_y = end[0, 2], end[0, 3]
        net_d = np.sqrt((final_x - initial_x)**2 + (final_y - initial_y)**2)

        if net_d >= displ_threshold_um:
            valid_beads.append(bead_id)

# --- Step 2: collect trajectories of valid beads ---
split_arr = []

for bead_id in valid_beads:
    bead_data = zero_arr[zero_arr[:, 0] == bead_id]
    if len(bead_data) == num_frames:
        split_arr.append(bead_data)

# --- Step 3: calculate alpha values ---
alpha_list = []

for one_traj in split_arr:
    msd_1traj = []
    for i in lagtime:
        sd_list = []
        for j in range(0, num_frames - i):
            sd = (one_traj[j + i, 2] - one_traj[j, 2]) ** 2 + (one_traj[j + i, 3] - one_traj[j, 3]) ** 2
            sd_list.append(sd)
        avg_sd = np.mean(sd_list)
        msd_1traj.append(avg_sd)

    x = np.log(lagtime_s[0:use_frames])
    y = np.log(msd_1traj[0:use_frames])
    m, b = np.polyfit(x, y, 1)
    alpha_list.append(m)

# --- Step 4: plot ---
num_beads = len(alpha_list)
mean_alpha = round(np.mean(alpha_list), 3)

print(f"Motors included in alpha analysis: {num_beads}")
print(f"The mean alpha value is {mean_alpha}")

fig, ax = plt.subplots(figsize=(9,8))

ax = sns.boxplot(y=alpha_list, palette="Oranges", saturation=0.65, width=0.4, linewidth=2, notch=True)
sns.swarmplot(y=alpha_list, marker="o", alpha=0.7, color=".25")

plt.ylabel('Alpha values', fontsize=20)
plt.setp(ax.get_yticklabels(), fontsize=16)
ax.set_title(f'Mean alpha value (20%) = {mean_alpha}', fontsize=20)
ax.autoscale()
plt.grid()
plt.show()

import pandas as pd
from google.colab import files

# ----------- USER INPUT -----------
base_filename = "2C UM 3_2"  # <<< change for each dataset
# ----------------------------------

# 1. Export filtered net displacement values
net_displ_df = pd.DataFrame({
    "BeadID": valid_beads,
    "NetDisplacement_um": net_displ  # this should already be in µm
})
net_displ_df.to_csv(f"{base_filename}_filtered_net_displacement.csv", index=False)

# 2. Export filtering summary
summary_df = pd.DataFrame({
    "Total motors analyzed": [total_motors],
    "Motors retained (≥ 0.1 µm)": [len(valid_beads)],
    "Motors filtered out": [total_motors - len(valid_beads)]
})
summary_df.to_csv(f"{base_filename}_net_displacement_filter_summary.csv", index=False)

# 3. Export alpha values of retained motors
alpha_df = pd.DataFrame({
    "BeadID": valid_beads,
    "Alpha": alpha_list
})
alpha_df.to_csv(f"{base_filename}_alpha_values_filtered_motors.csv", index=False)

# --- Google Colab Downloads ---
files.download(f"{base_filename}_filtered_net_displacement.csv")
files.download(f"{base_filename}_net_displacement_filter_summary.csv")
files.download(f"{base_filename}_alpha_values_filtered_motors.csv")